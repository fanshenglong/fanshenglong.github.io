<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>fansl的个人博客</title>
  
  <subtitle>fanshenglong</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://blog.fansl.com.cn/"/>
  <updated>2020-06-05T12:06:37.829Z</updated>
  <id>http://blog.fansl.com.cn/</id>
  
  <author>
    <name>fanshenglong</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>代理模式</title>
    <link href="http://blog.fansl.com.cn/2020/05/15/proxy/"/>
    <id>http://blog.fansl.com.cn/2020/05/15/proxy/</id>
    <published>2020-05-15T05:36:58.000Z</published>
    <updated>2020-06-05T12:06:37.829Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>代理模式也是一种很常见的设计模式。它使用代理对象完成用户请求，屏蔽用户对真实对象的访问。就如同现实中的代理一样，代理人被授权执行当事人的一些事宜，而无需当事人出面，从第三方的角度看，似乎当事人并不存在，因为他只和代理人通信。而事实上，代理人是要有当事人的授权，并且在核心问题上还需要请示当事人。<br>在现实中，使用代理的情况很普遍，而且原因也很多。比如，当事人因为某些隐私不方便出面，或者当事人不具备某些相关的专业技能，而需要一个职业人员来完成一些专业的操作，也可能由于当事人没有时间处理事务，而聘用代理人出面。<br>在软件设计中，使用代理模式的意图也很多，比如因为安全原因，需要屏蔽客户端直接访问真实对象；或者在远程调用中，需要使用代理类处理远程方法调用的技术细节；也可能是为了提升系统性能，对真实对象进行封装，从而达到延迟加载的目的。</p><a id="more"></a><h3 id="代理模式的结构"><a href="#代理模式的结构" class="headerlink" title="代理模式的结构"></a>代理模式的结构</h3><p>代理模式的主要参与者有4个。<br><strong>代理模式角色</strong><br>|角色|作用|<br>|-|-|<br>|主题接口|定义代理类和真实主题的公共对外方法，也是代理类代理真实主题的方法|<br>|真实主题|真正实现业务逻辑的类|<br>|代理类|用来代理和封装真实主题|<br>|Main|客户端，使用代理类和主题接口完成一些工作|<br>|||<br>以一个简单的示例来阐述使用代理模式实现延迟加载的方法及其意义。假设某客户端软件，有根据用户请求，去数据库查询数据的功能。在查询数据前，需要获得数据库连接，软件开启时，初始化系统的所有类，此时尝试获取数据库连接。当系统有大量的类似操作存在时（比如xml解析等），所有这些初始化操作的叠加，会使得系统的启动速度变得非常缓慢。为此，使用代理模式、代理类，封装对数据库查询中的初始化操作，当系统启动时，初始化这个代理类，而非真实的数据库查询类，而代理类什么都没有做，因此，它的构造是相当迅速的。<br>在系统启动时，将消耗资源最多的方法都使用代理模式分离，就可以加快系统的启动速度，减少用户的等待时间。而在用户真正做查询操作时，再由代理类，单独去加载真实的数据库查询类，完成用户的请求。这个过程就是使用代理模式实现了延迟加载。</p><blockquote><p><strong>注意：代理模式可以用于多种场合，如用于远程调用的网络代理，考虑安全因素的安全代理等。延迟加载只是代理模式的一种应用场景。</strong></p></blockquote><p>延迟加载的核心思想是：<code>如果当前并没有使用这个组件，则不需要真正地初始化它，使用一个代理对象替代它的原有的位置，只要在真正需要使用的时候，才对它进行加载。</code>使用代理模式的延迟加载时非常有意义的，首先，它可以在时间轴上分散系统压力，尤其在系统启动时，不必完成所有的初始化工作，从而加速启动时间；其次，对很多真实主题而言，在软件启动直到被关闭的整个过程中，可能根本不会被调用，初始化这些数据无疑是一种资源浪费。<br>系统显示了使用代理类封装数据库查询类后，系统的启动过程。<br><img src="http://oss.fansl.com.cn/image/blog/%E4%BB%A3%E7%90%86%E7%B1%BB%E7%9A%84%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B.jpg" alt="代理类工作流程"><br>上图显示了使用代理类封装数据库查询类后，系统的启动过程。<br>若系统不使用代理模式，则在启动时就要初始化DBQuery对象，而使用代理模式后，启动时只需要初始化一个轻量级的对象DBQueryProxy.<br>系统的接口如下图<br><img src="http://oss.fansl.com.cn/image/blog/%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F%E7%9A%84%E4%B8%80%E7%A7%8D%E5%AE%9E%E7%8E%B0.jpg" alt="代理模式的一种实现"><br>IDBQuery是主题接口，定义代理类和真实类需要对外提供的服务，在本例中定义了实现数据库查询的公共方法request()函数。DBQuery是真实主题，负责实际的业务操作，DBQueryProxy是DBQuery的代理类。</p><h3 id="代理模式的实现和使用"><a href="#代理模式的实现和使用" class="headerlink" title="代理模式的实现和使用"></a>代理模式的实现和使用</h3><p>基于以上设计，IDBQuery的实现如下，它只有一个request()方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IDBQuery</span></span>&#123;</span><br><span class="line">    <span class="function">String <span class="title">request</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>DBQuery实现如下，它是一个重量级对象，构造会比较慢：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DBQuery</span> <span class="keyword">implements</span> <span class="title">IDBQuery</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DBQuery</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);<span class="comment">//模拟链接数据库等耗时操作</span></span><br><span class="line">        &#125;<span class="keyword">catch</span>(InterruptedException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">request</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"request string"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代理类DBQueryProxy是轻量级对象，创建很快，用于替代DBQuery的位置：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DBQueryProxy</span> <span class="keyword">implements</span> <span class="title">IDBQuery</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> DBQuery real = <span class="keyword">null</span>;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">request</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//真正需要的时候，才创建真实对象,创建过程可能很慢</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">null</span> == real)&#123;</span><br><span class="line">            real = <span class="keyword">new</span> DBQuery();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//在多线程环境下，这里返回一个虚假类，类似于Future模式</span></span><br><span class="line">        <span class="keyword">return</span> real.request();</span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后，主函数如下，它引用IDBQuery接口，比使用代理类工作：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span>&#123;</span><br><span class="line">        IDBQuery q = <span class="keyword">new</span> DBQueryProxy();<span class="comment">//使用代理</span></span><br><span class="line">        q.request();<span class="comment">//在真正使用时才创建真实对象</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong>注意：</strong>将代理模式用于实现延迟加载，可以有效地提升系统的启动速度，对改善用户体验有很大的帮助。</p></blockquote><h3 id="动态代理介绍"><a href="#动态代理介绍" class="headerlink" title="动态代理介绍"></a>动态代理介绍</h3><p>动态代理是指在运行时，动态生成代理类。即，代理类的字节码将在运行时生成并载入当前的ClassLoader.与静态代理类相比，动态类有诸多好处。</p><ul><li>不需要为真实主题方法写一个形式上完全一样的封装类，假如主题接口中的方法很多，为每一个接口写一个代理方法也是非常烦人的事，如果接口有变动，则真实主题和代理类都要修改，不利于系统维护；</li><li>使用一些动态代理的生成方法甚至可以在运行时指定代理类的执行逻辑，从而大大提升系统灵活性。<blockquote><p><strong>注意：</strong>动态代理使用字节码动态生成加载技术，在运行时生成并加载类。</p></blockquote></li></ul><p>生成动态代理类的方法很多，如，JDK自带的动态代理、CGLIB、Javassist或者ASM库。JDK的动态代理使用简单，它内置于JDK中，因此不需要引入第三方Jar包，但相对功能较弱。CGLIB和Javassist都是高级的字节码生成库，总体性能比JDK自带的动态代理好，而且功能十分强大。ASM是低级的字节码生成工具，使用ASM以及近乎于在使用Java bytecode编程，对开发人员要求最高，当然，也是性能最好的一种动态代理生成工具。但ASM的使用过于繁琐，而且性能也没有数量级的提升，于CGLIB等高级字节码生成工具相比，ASM程序的可维护性也较差，如果不是对性能有苛刻要求的场合，还是推荐使用CGLIB或者Javassist.</p><h3 id="动态代理实现"><a href="#动态代理实现" class="headerlink" title="动态代理实现"></a>动态代理实现</h3><p>以上例中的DBQueryProxy为例，使用动态代理生成动态类，替代上例中的DBQueryProxy。首先，使用JDK的动态代理生成代理对象。JDK的动态代理需要实现一个处理方法调用Handler,用于实现代理方法的内部逻辑。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JdkDbQueryHandler</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span></span>&#123;</span><br><span class="line">    IDBQuery real = <span class="keyword">null</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy,Method method,Object[] args)</span> <span class="keyword">throws</span> Throwable</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> == real)&#123;</span><br><span class="line">            real = <span class="keyword">new</span> DBQuery();<span class="comment">//如果第一次调用，生成真实的对象</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> real.request();<span class="comment">//使用真实主题完成实际操作</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上代码实现了一个Handler,可以看到，它的内部逻辑和DBQueryProxy是类似的。在调用真实主题的方法前，先尝试生成真实主题对象。接着，需要使用这个Handler生成动态代理对象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> IDBQuery <span class="title">createJdkProxy</span><span class="params">()</span></span>&#123;</span><br><span class="line">    IDBQuery jdkProxy = (IDBQuery) Proxy.newProxyInstance(</span><br><span class="line">        ClassLoader.getSystemClassLoader(),</span><br><span class="line">        <span class="keyword">new</span> Class[]&#123;IDBQuery<span class="class">.<span class="keyword">class</span>&#125;,</span></span><br><span class="line"><span class="class">        <span class="title">new</span> <span class="title">JdkDbQueryHandler</span>())</span>;</span><br><span class="line">    <span class="keyword">return</span> jdkProxy;       </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上代码生成一个实现了IDBQuery接口的代理类，代理类的内部逻辑有jdkDbQueryHandler决定。生成代理类后，有newProxyInstance()方法返回该代理类的一个实例。至此，一个完整的JD动态代理就完成了。<br>CGLIB和Javassist的动态代理的使用和JDK的动态代理非常类似。下面，尝试用CGLIB生成动态代理。CGLIB也需要实现一个处理代理逻辑的切入类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CglibDbQueryInterceptor</span> <span class="keyword">implements</span> <span class="title">MethodInterceptor</span></span>&#123;</span><br><span class="line">    IDBQuery real = <span class="keyword">null</span>;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">intercept</span><span class="params">(Object arg0,Method arg1,Object[] arg2,MethodProxy arg3 )</span><span class="keyword">throws</span> Throwable</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (real == <span class="keyword">null</span>)&#123;</span><br><span class="line">            real = <span class="keyword">new</span> DBQuery();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> real.request();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个切入对象的基础上，可以生成动态代理：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> IDBQuery <span class="title">createCglibProxy</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Enhancer enhancer = <span class="keyword">new</span> Enhancer();</span><br><span class="line">    enhancer.setCallback(<span class="keyword">new</span> CglibDbQueryInterceptor());<span class="comment">//指定切入器，定义代理类逻辑</span></span><br><span class="line">    enhancer.setInterfaces(<span class="keyword">new</span> Class[]&#123;IDBQuery<span class="class">.<span class="keyword">class</span>&#125;)</span>;<span class="comment">//指定实现的接口</span></span><br><span class="line">    IDBQuery cglibProxy = (IDBQuery)enhancer.create();<span class="comment">//生成代理类的实例</span></span><br><span class="line">    <span class="keyword">return</span> cglibProxy;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用Javassist生成动态代理可以使用两种方式：一种是使用代理工厂创建，另一种通过使用动态代理创建。使用代理工厂创建时，方法与CGLIB类似，也需要实现一个用于代理逻辑处理的Handler:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JavassistDynDbQueryHandler</span> <span class="keyword">implements</span> <span class="title">MethodHandler</span></span>&#123;</span><br><span class="line">    IDBQuery real = <span class="keyword">null</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object arg0,Method arg1,Method arg2,Object[] arg3)</span> <span class="keyword">throws</span> Throwable</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">null</span> == real)&#123;</span><br><span class="line">            real = <span class="keyword">new</span> DBQuery();</span><br><span class="line">        &#125;    </span><br><span class="line">        <span class="keyword">return</span> real.request();</span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以这个Handler为基础，创建动态Javassist代理：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> IDBQuery createJavassitDynProxy <span class="keyword">throws</span> Exception&#123;</span><br><span class="line"></span><br><span class="line">    ProxyFactory proxyFactory = <span class="keyword">new</span> ProxyFactory();</span><br><span class="line">    proxyFactory.setInterfaces(<span class="keyword">new</span> Class[]&#123;DBQuery<span class="class">.<span class="keyword">class</span>&#125;)</span>;<span class="comment">//指定接口</span></span><br><span class="line">    Class proxyClass = proxyFactory.createClass();</span><br><span class="line">    IDBQuery javassistProxy = (IDBQuery)proxyClass.newInstance();<span class="comment">//设置handler处理器</span></span><br><span class="line">    ((ProxyObejct)javassistProxy).setHandler(<span class="keyword">new</span> JavassistDynDbQueryHandler());</span><br><span class="line">    <span class="keyword">return</span> javassistProxy;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Javassist使用动态Java代码创建代理的过程和前文的方法略有不同。Javassist内部可以通过动态Java代码，生成字节码。这种方式创建的动态代理可以非常灵活，甚至可以在运行时生成业务逻辑。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> IDBQuery <span class="title">createJavassistBytecodeDynamicProxy</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ClassPool mPool = <span class="keyword">new</span> ClassPool(<span class="keyword">true</span>);</span><br><span class="line">        <span class="comment">//定义类名</span></span><br><span class="line">        CtClass mCtc = mPool.makeClass(IDBQuery.class.getName()+"JavassistBytecodeProxy");</span><br><span class="line">        <span class="comment">//需要实现的接口</span></span><br><span class="line">        mCtc.addInterface(mPool.get(IDBQuery<span class="class">.<span class="keyword">class</span>.<span class="title">getName</span>()))</span>;</span><br><span class="line">        <span class="comment">//添加构造函数</span></span><br><span class="line">        mCtc.addConstructor(CtNewConstructor.defaultConstructor(mCtc));</span><br><span class="line">        <span class="comment">//添加类的字段信息，使用动态java代码</span></span><br><span class="line">        mCtc.addField(CtField.make("public " + IDBQuery.class.getName() + " real;",mCtc));</span><br><span class="line">        String dbqueryname = DBQuery<span class="class">.<span class="keyword">class</span>.<span class="title">getName</span>()</span>;</span><br><span class="line">        <span class="comment">//添加方法，这里使用动态Java代码指定内部逻辑</span></span><br><span class="line">        mCtc.addMethod(CtNewMethod.make(<span class="string">"public String request() &#123;if (real == null)&#123;"</span> +</span><br><span class="line">                <span class="string">"real = new "</span>+dbqueryname+<span class="string">"();&#125; return real.request();&#125;"</span>,mCtc));</span><br><span class="line">        <span class="comment">//基于以上信息，生成动态类</span></span><br><span class="line">        Class pc = mCtc.toClass();</span><br><span class="line">        <span class="comment">//生成动态类的实例</span></span><br><span class="line">        IDBQuery bytecodeProxy = (IDBQuery) pc.newInstance();</span><br><span class="line">        <span class="keyword">return</span> bytecodeProxy;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>在以上代码中，使用CtField.make()方法和CtNewMethod.make()方法在运行时生成了代理类的字段和方法。这些逻辑有Javassist的CtClass对象处理，将Java代码转换为对应的字节码，并生成动态代理类的实例。</p><blockquote><p><strong>注意：</strong>与静态代理相比，动态代理可以很大幅度地减少代码行数，并提升系统的灵活性。</p></blockquote><p>在Java中，动态代理类的生成主要涉及对ClassLoader的使用。这里以CGLIB为例，简要阐述动态类的加载过程。使用CGLIB生成动态代理，首先需要生成Enhancer类实例，并指定用于处理代理业务的回调类。在Enhancer.create()方法中，会使用DefaultGeneratorStrategy.Generate()方法生成动态代理类的字节码，并保存在byte数组中。接着使用ReflectUtils.defineClass()方法，通过反射，调用ClassLoader.defineClass()方法，将字节码封装到ClassLoader中，完成类的加载。最后使用RelfectUtils.newInstance()方法，通过发射，生成动态类的实例，并返回该实例。无论使用何种方法生成动态代理，虽然实现细节不同，但主要逻辑都相似：</p><blockquote><p><code>根据指定的回调类生成Class字节码</code>-&gt;<code>通过defineClass()将字节码定义为类</code>-&gt;<code>使用反射机制生成该类的实例</code></p></blockquote><blockquote><p><strong>注意：</strong>就动态代理的方法调用性能而言，CGLIB和Javassist的基本动态代码的代理都优于JDK自带的动态代理。此外，JDK的动态代理要就代理类和真实主题都实现同一个接口，而CGLIB和Javassist没有强制要求。</p></blockquote><p><em>参考文章:</em>  </p><ul><li><a href="javascript:void(0)">Java程序性能优化</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;代理模式也是一种很常见的设计模式。它使用代理对象完成用户请求，屏蔽用户对真实对象的访问。就如同现实中的代理一样，代理人被授权执行当事人的一些事宜，而无需当事人出面，从第三方的角度看，似乎当事人并不存在，因为他只和代理人通信。而事实上，代理人是要有当事人的授权，并且在核心问题上还需要请示当事人。&lt;br&gt;在现实中，使用代理的情况很普遍，而且原因也很多。比如，当事人因为某些隐私不方便出面，或者当事人不具备某些相关的专业技能，而需要一个职业人员来完成一些专业的操作，也可能由于当事人没有时间处理事务，而聘用代理人出面。&lt;br&gt;在软件设计中，使用代理模式的意图也很多，比如因为安全原因，需要屏蔽客户端直接访问真实对象；或者在远程调用中，需要使用代理类处理远程方法调用的技术细节；也可能是为了提升系统性能，对真实对象进行封装，从而达到延迟加载的目的。&lt;/p&gt;
    
    </summary>
    
    
      <category term="设计模式" scheme="http://blog.fansl.com.cn/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="Java" scheme="http://blog.fansl.com.cn/tags/Java/"/>
    
      <category term="设计模式" scheme="http://blog.fansl.com.cn/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>hexo创建一篇新文章或者新的页面</title>
    <link href="http://blog.fansl.com.cn/2020/05/13/hexo/"/>
    <id>http://blog.fansl.com.cn/2020/05/13/hexo/</id>
    <published>2020-05-13T09:49:47.000Z</published>
    <updated>2020-06-05T12:06:37.833Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>你可以执行<code>hexo new [layout] &lt;title&gt;</code>命令来创建一篇新文章或者新的页面</p><a id="more"></a><p>您可以在命令中指定文章的布局（layout），默认为 <code>post</code>，可以通过修改 <code>_config.yml</code> 中的 <code>default_layout</code> 参数来指定默认布局。</p><h3 id="布局-layout"><a href="#布局-layout" class="headerlink" title="布局(layout)"></a><em>布局(layout)</em></h3><p>Hexo 有三种默认布局：<code>post</code>、<code>page</code> 和 <code>draft</code>。在创建者三种不同类型的文件时，它们将会被保存到不同的路径；而您自定义的其他布局和 post 相同，都将储存到 <code>source/_posts</code> 文件夹。</p><table><thead><tr><th>布局</th><th>路径</th></tr></thead><tbody><tr><td>post</td><td>source/_posts</td></tr><tr><td>page</td><td>source</td></tr><tr><td>draft</td><td>source/_drafts</td></tr><tr><td></td><td></td></tr></tbody></table><h3 id="其他参数"><a href="#其他参数" class="headerlink" title="其他参数"></a><em>其他参数</em></h3><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>-p, –path</td><td>自定义新文章的路径</td></tr><tr><td>-r, –replace</td><td>如果存在同名文章，将其替换</td></tr><tr><td>-s, –slug</td><td>文章的 Slug，作为新文章的文件名和发布后的 URL</td></tr><tr><td></td><td></td></tr></tbody></table><p>默认情况下，Hexo 会使用文章的标题来决定文章文件的路径。对于独立页面来说，Hexo 会创建一个以标题为名字的目录，并在目录中放置一个 <code>index.md</code> 文件。你可以使用 <code>--path</code> 参数来覆盖上述行为、自行决定文件的目录：</p><blockquote><p>hexo new page –path about/me “About me”</p></blockquote><p>以上命令会创建一个 <code>source/about/me.md</code> 文件，同时 Front Matter 中的 title 为 <code>&quot;About me&quot;</code><br><em>注意！title 是必须指定的！如果你这么做并不能达到你的目的：</em></p><blockquote><p>hexo new page –path about/me</p></blockquote><p>此时 Hexo 会创建 <code>source/_posts/about/me.md</code>，同时 <code>me.md</code> 的 Front Matter 中的 title 为 <code>&quot;page&quot;</code>。这是因为在上述命令中，hexo-cli 将 <code>page</code> 视为指定文章的标题、并采用默认的 <code>layout</code>。</p><p><em>参考文章:</em>  </p><ul><li><a href="https://hexo.io/zh-cn/docs/writing">hexo-基本操作-写作</a></li><li><a href="https://hexo.io/zh-cn/docs/commands">hexo-开始使用-命令</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;你可以执行&lt;code&gt;hexo new [layout] &amp;lt;title&amp;gt;&lt;/code&gt;命令来创建一篇新文章或者新的页面&lt;/p&gt;
    
    </summary>
    
    
      <category term="hexo" scheme="http://blog.fansl.com.cn/categories/hexo/"/>
    
    
      <category term="hexo" scheme="http://blog.fansl.com.cn/tags/hexo/"/>
    
  </entry>
  
  <entry>
    <title>单例模式</title>
    <link href="http://blog.fansl.com.cn/2020/05/13/singleton/"/>
    <id>http://blog.fansl.com.cn/2020/05/13/singleton/</id>
    <published>2020-05-13T09:49:11.000Z</published>
    <updated>2020-06-05T12:06:37.829Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>单例模式是设计模式中使用最为普遍的模式之一。它是一种对象创建模式，用于生产一个对象的具体实例，它可以确保系统中一个类只产生场一个实例。<br>在Java语言中，这样的行为能带来的两大好处：<br>（1）减少频繁使用的对象的创建时间，节省系统开销。<br>（2）new操作减少-&gt;系统内存使用频率降低，减轻GC压力，缩短GC停顿时间。<br>因此对于系统的关键组件和频繁使用的对象，使用单例模式便可以有效的改善系统的性能。</p><a id="more"></a><p>单例的参与者只有单例类和使用者两个角色。<br><code>单例模式角色</code></p><table><thead><tr><th>角色</th><th>作用</th></tr></thead><tbody><tr><td>单例类</td><td>提供单例的工厂，返回单例</td></tr><tr><td>使用者</td><td>获取并使用单例类</td></tr><tr><td></td><td></td></tr></tbody></table><p><img src="http://oss.fansl.com.cn/image/blog/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E7%B1%BB%E5%9B%BE.png" alt="单例模式类图"></p><hr><p>单例模式的核心在于通过一个接口返回唯一的对象实例。例如下面的单例实现：</p><figure class="highlight java"><figcaption><span>点击展开代码 >folded</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Singleton is create"</span>); <span class="comment">// 创建单例的过程可能会比较慢</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意</strong>,首先单例类必须要有一个<code>private</code>访问级别的构造函数，确保单例不会在系统中的其他代码内被实例化；其次，<code>instance</code>成员变量和<code>getInstance()</code>方法必须是<code>static</code>的。</p><hr><p>这种单例的实现方式非常简单，而且十分可靠。它的唯一的不足是无法对<code>instance</code>实例做延迟加载。假如单例的创建过程很慢，而由于<code>instance</code>成员变量是<code>static</code>定义的，因此在JVM加载单例类时，单例对象就会被创建，如果此时，这个单例类在系统中扮演其他角色，那么在任何使用这个单例类的地方都会初始化这个单例变量，而不管是否会被用到。比如单例类作为String工厂，用于创建一些字符串（该类即用于创建单例Singleton，有用于创建String对象）：</p><figure class="highlight java"><figcaption><span>点击展开代码 >folded</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Singleton is create"</span>); <span class="comment">// 创建单例的过程可能会比较慢</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">createString</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">// 这是模拟单例类扮演其他角色</span></span><br><span class="line">        System.out.println(<span class="string">"createString in Singleton"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当使用<code>Singleton.createString()</code>执行任务时，程序输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Singleton is create </span><br><span class="line">createString in Singleton</span><br></pre></td></tr></table></figure><p>可以看到，虽然此时并没有使用单例类，但它还是被创建出来了，这也许是开发人员不想看到的。为了解决这个问题，并以此提高系统在相关函数调用时的反应速度，就需要引入延迟加载机制。</p><figure class="highlight java"><figcaption><span>点击展开代码 >folded</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LazySingleton</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">LazySingleton</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"LazySingleton is create"</span>); <span class="comment">//创建单例的过程可能会比较慢</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> LazySingleton instance = <span class="keyword">null</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> LazySingleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(instance == <span class="keyword">null</span>)&#123;</span><br><span class="line">            instance = <span class="keyword">new</span> LazySingleton();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先，对于静态成员变量<code>instance</code>初始值赋予<code>null</code>，确保系统启动时没有额外的负载；其次，在<code>getInstance()</code>工厂方法中，判断当前单例是否已经存在，若存在则返回，不存在则建立单例。这里尤其还要注意，<code>getInstance()</code>方法必须是同步的，否则在多线程环境下，当线程1在新建单例时，完成赋值操作前，线程2可能判断<code>instance</code>为<code>null</code>，故线程2将启动新建单例的程序，而导致多个实例被创建，故同步关键字是必须的。</p><p>使用上例中的单例实现，虽然实现了延迟加载功能，但和第一种方法相比，它引入了同步关键字，因此在多线程环境中，它的时耗要远远大于第一种单例模式。</p><p>以下测试代码就说明了这个问题：</p><figure class="highlight java"><figcaption><span>点击展开代码 >folded</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">100000</span>;i++)&#123;</span><br><span class="line">Singleton.getInstance();</span><br><span class="line"><span class="comment">// LazySingleton.getInstance();</span></span><br><span class="line">System.out.println(<span class="string">"spend:"</span>+(System.currentTimeMillis()-beginTime));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>开启5个线程同时完成以上代码的运行，使用第一种类型的单例耗时<code>1ms</code>,而<code>LazySingleton</code>却相对耗时约<code>300ms</code>。性能至少相差2个数量级。</p><blockquote><p><strong>注意，测试数据绝对值不必太过关注，只关注相对耗时即可。</strong></p></blockquote><hr><p>为了使用延迟加载引入的同步关键字反而降低了系统性能，这不是我们希望看到的，为了解决这个问题，对其进行改进：</p><figure class="highlight java"><figcaption><span>点击展开代码 >folded</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StaticSingleton</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">StaticSingleton</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"StaticSingleton is create"</span>); <span class="comment">//创建单例的过程可能会比较慢</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonHolder</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> StaticSingleton instance = <span class="keyword">new</span> StaticSingleton();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> StaticSingleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> SingletonHolder.instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个实现中，单例模式使用内部类来维护单例实例，当<code>StaticSingleton</code>被加载时，其内部类并不会被初始化，故可以确保当<code>StaticSingleton</code>被载入JVM时，不会初始化单例类，而当<code>getInstance()</code>方法被调用时，才会加载<code>SingletonHolder</code>，从而初始化<code>instance</code>。同时，由于实例的建立是在类加载时完成，故天生对多线程友好，<code>getInstance()</code>方法不需要使用同步关键字。因此，这种实现方式同时兼备以上两种实现优点。</p><p><strong>使用内部类的方式实现单例，既可以做到延迟加载，也不必使用同步关键字，是一种比较完善的实现</strong></p><hr><p>通常情况下，用以上实现的单例已经可以确保在系统中只存在唯一实例了。但仍然有例外情况，可能导致系统生成很多个实例，比如，在代码中，通过反射机制，强行调用单例类的私有构造函数，生成多个单例。</p><p><strong>一个可以序列化的单例</strong></p><figure class="highlight java"><figcaption><span>点击展开代码 >folded</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SerSingleton</span> <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span></span>&#123;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">SerSingleton</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"SerSingleton is create"</span>); <span class="comment">//创建单例的过程可能会比较慢</span></span><br><span class="line">        name =  <span class="string">"SerSingleton"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> SerSingleton instance = <span class="keyword">new</span> SerSingleton();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SerSingleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">createSting</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"createString in Singleton"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> Object <span class="title">readResolve</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">// 阻止生成新的实例，总是返回当前对象</span></span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试代码如下：</p><figure class="highlight java"><figcaption><span>点击展开代码 >folded</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">    SerSingleton s1 = <span class="keyword">null</span>;</span><br><span class="line">    SerSingleton s = SerSingleton.getInstance();</span><br><span class="line">    <span class="comment">//先将实例序列化到文件</span></span><br><span class="line">    FileOutputSteam fos = <span class="keyword">new</span> FileOutputStream(<span class="string">"SerSingleton.txt"</span>);</span><br><span class="line">    ObjectOutputStream oos = <span class="keyword">new</span> ObjectOutputStream(fos);</span><br><span class="line">    oos.writeObject(s);</span><br><span class="line">    oos.flush;</span><br><span class="line">    oos.close;</span><br><span class="line">    <span class="comment">// 从文件读出原有的单例类</span></span><br><span class="line">    FileInputStream fis = <span class="keyword">new</span> FileInputStream(<span class="string">"SerSingleton.txt"</span>);</span><br><span class="line">    ObjectInputStream ois = <span class="keyword">new</span> ObjectInputStream(fis);</span><br><span class="line">    s1 = (SerSingleton)ois.readObject();</span><br><span class="line">    </span><br><span class="line">    Assert.assertEquals(s,s1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用一段测试单例的序列化和反序列化，当去掉<code>SerSingleton</code>代码中的<code>readResolve()</code>方法时，抛出异常，<code>s</code>和<code>s1</code>不是同一实例,反序列化后，生成多个对象实例。添加<code>readResolve()</code>方法后，程序未报异常。说明，即便是反序列化，仍然保持了单例的特性。<strong>实现了私有的<code>readResolve()</code>方法后，<code>readObject()</code>已经形同虚设，它直接使用<code>readResolve()</code>方法替换了原本的返回值，从而在形式上构造了单例。</strong></p><blockquote><p><strong>序列化和反序列化可能会破坏单例。一般来说，对单例进行序列化和反序列化的场景不多见，如果存在就需要多加注意。</strong></p></blockquote><hr><p>参考文章:  </p><ul><li><a href="javascript:void(0)">Java程序性能优化</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;单例模式是设计模式中使用最为普遍的模式之一。它是一种对象创建模式，用于生产一个对象的具体实例，它可以确保系统中一个类只产生场一个实例。&lt;br&gt;在Java语言中，这样的行为能带来的两大好处：&lt;br&gt;（1）减少频繁使用的对象的创建时间，节省系统开销。&lt;br&gt;（2）new操作减少-&amp;gt;系统内存使用频率降低，减轻GC压力，缩短GC停顿时间。&lt;br&gt;因此对于系统的关键组件和频繁使用的对象，使用单例模式便可以有效的改善系统的性能。&lt;/p&gt;
    
    </summary>
    
    
      <category term="设计模式" scheme="http://blog.fansl.com.cn/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="Java" scheme="http://blog.fansl.com.cn/tags/Java/"/>
    
      <category term="设计模式" scheme="http://blog.fansl.com.cn/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>linux查询端口占用</title>
    <link href="http://blog.fansl.com.cn/2020/05/07/linux-code-1/"/>
    <id>http://blog.fansl.com.cn/2020/05/07/linux-code-1/</id>
    <published>2020-05-07T10:58:04.000Z</published>
    <updated>2020-06-05T12:06:37.833Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>部署服务时经常使用到的linux命令</p><a id="more"></a><figure class="highlight bash"><figcaption><span>点击展开代码 >unfolded</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查询端口占用</span></span><br><span class="line">netstat -lnpt |grep 5672</span><br><span class="line"><span class="comment"># 查看进程的详细信息 xxxx表示PID</span></span><br><span class="line">ps xxxx </span><br><span class="line"><span class="comment"># 中止进程,xxxx表示PID</span></span><br><span class="line"><span class="built_in">kill</span> -9 xxxx</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;部署服务时经常使用到的linux命令&lt;/p&gt;
    
    </summary>
    
    
      <category term="linux" scheme="http://blog.fansl.com.cn/categories/linux/"/>
    
    
      <category term="linux" scheme="http://blog.fansl.com.cn/tags/linux/"/>
    
      <category term="实用" scheme="http://blog.fansl.com.cn/tags/%E5%AE%9E%E7%94%A8/"/>
    
  </entry>
  
  <entry>
    <title>linux端口放行</title>
    <link href="http://blog.fansl.com.cn/2020/05/07/linux-code/"/>
    <id>http://blog.fansl.com.cn/2020/05/07/linux-code/</id>
    <published>2020-05-07T10:35:45.000Z</published>
    <updated>2020-06-05T12:06:37.833Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>配置某个服务端口时，查询端口是否开发等一些相关操作</p><a id="more"></a><figure class="highlight bash"><figcaption><span>点击展开代码 >unfolded</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 开放xxxx端口</span></span><br><span class="line"> firewall-cmd --zone=public --add-port=xxxx/tcp --permanent </span><br><span class="line"><span class="comment"># 设置生效</span></span><br><span class="line"> firewall-cmd --reload</span><br><span class="line"><span class="comment"># 关闭xxxx端口</span></span><br><span class="line"> firewall-cmd --zone=public --remove-port=xxxx/tcp --permanent</span><br><span class="line"><span class="comment"># 查看防火墙所有开放的端口</span></span><br><span class="line"> firewall-cmd --zone=public --list-ports</span><br><span class="line"><span class="comment"># 关闭防火墙</span></span><br><span class="line"> systemctl stop firewalld.service</span><br><span class="line"><span class="comment"># 查看防火墙状态</span></span><br><span class="line"> firewall-cmd --state</span><br><span class="line"><span class="comment"># 查询xxxx端口是否开启成功 </span></span><br><span class="line"> firewall-cmd --query-port=xxxx/tcp </span><br><span class="line"><span class="comment"># 查看监听的端口</span></span><br><span class="line"> netstat -lnpt</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;配置某个服务端口时，查询端口是否开发等一些相关操作&lt;/p&gt;
    
    </summary>
    
    
      <category term="linux" scheme="http://blog.fansl.com.cn/categories/linux/"/>
    
    
      <category term="linux" scheme="http://blog.fansl.com.cn/tags/linux/"/>
    
      <category term="实用" scheme="http://blog.fansl.com.cn/tags/%E5%AE%9E%E7%94%A8/"/>
    
  </entry>
  
  <entry>
    <title>linux命令</title>
    <link href="http://blog.fansl.com.cn/2020/04/28/fotwg6/"/>
    <id>http://blog.fansl.com.cn/2020/04/28/fotwg6/</id>
    <published>2020-04-28T10:11:39.000Z</published>
    <updated>2020-06-05T12:07:11.786Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>一些有用的linux命令<br /><a id="more"></a><br><a name="l0xmF"></a></p><h3 id="系统"><a href="#系统" class="headerlink" title="系统"></a>系统</h3><hr><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">uname -a <span class="comment"># 查看内核、操作系统、cpu信息</span></span><br><span class="line">head -n 1 /etc/issue  <span class="comment"># 查看操作系统版本</span></span><br><span class="line">cat /proc/cpuinfo     <span class="comment"># 查看cpu信息</span></span><br><span class="line">hostname              <span class="comment"># 查看计算机名</span></span><br><span class="line">lspci -tv<span class="comment"># 列出所有PCI设备（需要yum install pciutils）</span></span><br><span class="line">lsusb -tv  <span class="comment"># 列出所有USB设备</span></span><br><span class="line">lsmod                 <span class="comment"># 列出加载的内核模块</span></span><br><span class="line">env                   <span class="comment"># 查看环境变量</span></span><br><span class="line">lspci | grep Ethernet <span class="comment"># 查看网卡型号</span></span><br></pre></td></tr></table></figure><p><a name="AN3p2"></a></p><h3 id="资源"><a href="#资源" class="headerlink" title="资源"></a>资源</h3><hr><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">free -m                <span class="comment"># 查看内存使用量和交换区使用量</span></span><br><span class="line">df -h                  <span class="comment"># 查看各分区使用情况</span></span><br><span class="line">du -sh &lt;目录名&gt;         <span class="comment"># 查看指定目录的大小</span></span><br><span class="line">grep MemTotal /proc/meminfo   <span class="comment"># 查看内存总量</span></span><br><span class="line">grep MemFree /proc/meminfo    <span class="comment"># 查看空闲内存量</span></span><br><span class="line">uptime                 <span class="comment"># 查看系统运行时间、用户数、负载</span></span><br><span class="line">cat /proc/loadavg      <span class="comment"># 查看系统负载</span></span><br></pre></td></tr></table></figure><p><a name="fqUG6"></a></p><h3 id="磁盘和分区"><a href="#磁盘和分区" class="headerlink" title="磁盘和分区"></a>磁盘和分区</h3><hr><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mount | column -t      <span class="comment"># 查看挂接的分区状态</span></span><br><span class="line">fdisk -l               <span class="comment"># 查看所有分区</span></span><br><span class="line">swapon -s              <span class="comment"># 查看所有交换分区</span></span><br><span class="line">hdparm -i /dev/hda     <span class="comment"># 查看磁盘参数(仅适用于IDE设备)</span></span><br><span class="line">dmesg | grep IDE       <span class="comment"># 查看启动时IDE设备检测状况</span></span><br></pre></td></tr></table></figure><p><a name="iKhur"></a></p><h3 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h3><hr><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ifconfig               <span class="comment"># 查看所有网络接口的属性</span></span><br><span class="line">iptables -L            <span class="comment"># 查看防火墙设置</span></span><br><span class="line">route -n               <span class="comment"># 查看路由表</span></span><br><span class="line">netstat -lntp          <span class="comment"># 查看所有监听端口</span></span><br><span class="line">netstat -antp          <span class="comment"># 查看所有已经建立的连接</span></span><br><span class="line">netstat -s             <span class="comment"># 查看网络统计信息</span></span><br></pre></td></tr></table></figure><p><a name="5L5F8"></a></p><h3 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h3><hr><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ps -ef                 <span class="comment"># 查看所有进程</span></span><br><span class="line">top                    <span class="comment"># 实时显示进程状态</span></span><br></pre></td></tr></table></figure><p><a name="nwlnT"></a></p><h3 id="程序"><a href="#程序" class="headerlink" title="程序"></a>程序</h3><hr><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pm -qa                <span class="comment"># 查看所有安装的软件包</span></span><br></pre></td></tr></table></figure><p><a name="ZvPUX"></a></p><h3 id="服务"><a href="#服务" class="headerlink" title="服务"></a>服务</h3><hr><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">chkconfig --list      <span class="comment"># 列出所有系统服务</span></span><br><span class="line">chkconfig --list | grep on    <span class="comment"># 列出所有启动的系统服务</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;一些有用的linux命令&lt;br /&gt;
    
    </summary>
    
    
      <category term="linux" scheme="http://blog.fansl.com.cn/categories/linux/"/>
    
    
      <category term="linux" scheme="http://blog.fansl.com.cn/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>博客第一期</title>
    <link href="http://blog.fansl.com.cn/2020/04/22/ny150b/"/>
    <id>http://blog.fansl.com.cn/2020/04/22/ny150b/</id>
    <published>2020-04-22T07:21:29.000Z</published>
    <updated>2020-06-05T12:07:11.786Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>该博客模版案例来自 <a href="#">@蚂蚁金服体验技术部</a> <br /></p><a id="more"></a><p><a name="az6uF"></a></p><h3 id="插入带链接的标题（ctrl-K）Best-Year-in-Music"><a href="#插入带链接的标题（ctrl-K）Best-Year-in-Music" class="headerlink" title="插入带链接的标题（ctrl+K）Best Year in Music"></a>插入带链接的标题（ctrl+K）<a href="https://pudding.cool/projects/music-history/">Best Year in Music</a></h3><p>这幅可视化作品展示了 1960 年以来，Billboard 历年榜单的前五名音乐的变化情况，效果呈现设计感十足，还可以在聆听音乐的同时回顾音乐的变迁史。<br /><img src="https://cdn.nlark.com/yuque/0/2019/png/85075/1569743511172-7dfff3da-684a-4902-babc-cd9117fe3b7a.png#align=left&display=inline&height=648&margin=%5Bobject%20Object%5D&name=image.png&originHeight=1296&originWidth=2868&size=965213&status=done&style=none&width=1434" alt="image.png"><br /><em>插入图片，点击图片，设置图片大小</em><br />值得一提的是，作者正是大名鼎鼎的数据新闻站点 <a href="https://pudding.cool/">The Pudding</a>。作为可视化新闻媒体中的姣姣者，The Pudding 擅长对那些兼具信息量和娱乐度的争议性话题进行可视化呈现，来使得复杂的观点变得更容易被公众理解。该团队虽然仅由数名全职记者和工程师组成，但战斗力强悍，目前已有数十个大型的数据可视化作品。<br />输入作者 <a href="/dengfuping">@诸岳(dengfuping)</a><br /></p><p><a name="xyPrr"></a></p><h3 id="Road-Suffixes-in-the-USA"><a href="#Road-Suffixes-in-the-USA" class="headerlink" title="Road Suffixes in the USA"></a><a href="https://erdavis.com/2019/07/04/road-suffixes-in-the-usa-take-2/">Road Suffixes in the USA</a></h3><p>美国道路命名多种多样，例如著名的纽约第五大道（Fifth Avenue），又或者凤凰城（Phoenix）的Washington Street，Thomas Road，Union Hill Drive等。不同的道路，有不同的叫法，Avenue, Street, Road, Drive等等。想了解更多关于美国道路命名可以参考<a href="http://blog.sina.com.cn/s/blog_7010d1db0101he93.html">这篇文章</a>。<br />作者用R语言统计了美国每个县的每种道路后缀（例如Avenue）的总里程，并把每个县总里程最大的道路后缀通过颜色映射到地图上。可以看出美国大部分县的道路都是以Rd(Road的缩写)结尾的。<br /><img src="https://cdn.nlark.com/yuque/0/2019/png/85075/1569743625739-f1c8b376-5632-4d08-8fcc-56142f0b0c1a.png#align=left&display=inline&height=603&margin=%5Bobject%20Object%5D&name=road-suffix-map.png&originHeight=1767&originWidth=2048&size=328604&status=done&style=none&width=699" alt="road-suffix-map.png"><br /><em>插入图片，点击图片，设置图片大小</em><br /><br>另外还以柱状图的方式展示了每种道路后缀的总里程（英里）：<br /><img src="https://cdn.nlark.com/yuque/0/2019/png/85075/1569743625720-b8759449-4b6a-4b11-bbc0-896fe8dca73e.png#align=left&display=inline&height=737&margin=%5Bobject%20Object%5D&name=road-suffix-bar.png&originHeight=737&originWidth=890&size=23572&status=done&style=none&width=890" alt="road-suffix-bar.png"><br />by <a href="/changzhe">@长哲(changzhe)</a><br /></p><p><a name="hduVH"></a></p><h1 id="「加餐」Hello-World-图可视化"><a href="#「加餐」Hello-World-图可视化" class="headerlink" title="「加餐」Hello World 图可视化"></a><a href="https://zhuanlan.zhihu.com/p/83685690">「</a><a href="https://zhuanlan.zhihu.com/p/83685690">加餐」</a><a href="https://zhuanlan.zhihu.com/p/83685690">Hello World 图可视化</a></h1><p>图可视化是信息可视化的子领域，它通过展示元素、关系，帮助用户获取数据的洞悉能力。它已被广泛地应用在流程图、社交网络、英特网、蛋白质网络等关系数据的呈现。<br /><a href="https://zhuanlan.zhihu.com/p/83685690">本文</a>由 AntV 团队 <a href="/shiwu-5wap2">@十吾(shiwu-5wap2)</a> 👆撰写，参考自[1][2]两篇图可视化学术论文，简要介绍图可视化的历史、背景、机遇与挑战。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;该博客模版案例来自 &lt;a href=&quot;#&quot;&gt;@蚂蚁金服体验技术部&lt;/a&gt; &lt;br /&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="测试" scheme="http://blog.fansl.com.cn/categories/%E6%B5%8B%E8%AF%95/"/>
    
    
      <category term="测试" scheme="http://blog.fansl.com.cn/tags/%E6%B5%8B%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>测试一下font-formatter</title>
    <link href="http://blog.fansl.com.cn/2020/04/22/wvwguf/"/>
    <id>http://blog.fansl.com.cn/2020/04/22/wvwguf/</id>
    <published>2020-04-22T06:21:33.000Z</published>
    <updated>2020-06-05T12:07:11.790Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>测试语雀front-matter<br /><a id="more"></a><br />没有内容了</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;测试语雀front-matter&lt;br /&gt;
    
    </summary>
    
    
      <category term="测试" scheme="http://blog.fansl.com.cn/categories/%E6%B5%8B%E8%AF%95/"/>
    
    
      <category term="测试" scheme="http://blog.fansl.com.cn/tags/%E6%B5%8B%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>面试官问分布式技术面试题，一脸懵逼怎么办?</title>
    <link href="http://blog.fansl.com.cn/2020/04/21/idl9gm/"/>
    <id>http://blog.fansl.com.cn/2020/04/21/idl9gm/</id>
    <published>2020-04-21T02:56:11.000Z</published>
    <updated>2020-06-05T12:07:11.790Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p><strong>分布式缓存，分布式消息队列，分布式服务框架</strong></p><blockquote><p>转载于：<a href="https://my.oschina.net/u/3728792/blog/3042368">https://my.oschina.net/u/3728792/blog/3042368</a></p></blockquote><p><br /><a id="more"></a><br><a name="DnBuF"></a></p><h2 id="1-分布式缓存"><a href="#1-分布式缓存" class="headerlink" title="1.分布式缓存"></a>1.分布式缓存</h2><p><a name="sOR4I"></a></p><h3 id="1-1-Redis-有什么数据类型？分别用于什么场景？"><a href="#1-1-Redis-有什么数据类型？分别用于什么场景？" class="headerlink" title="1.1 Redis 有什么数据类型？分别用于什么场景？"></a>1.1 Redis 有什么数据类型？分别用于什么场景？</h3><table><thead><tr><th>数据类型</th><th>可以存储的值</th><th>操作</th></tr></thead><tbody><tr><td>STRING</td><td>字符串、整数或者浮点数</td><td>对整个字符串或者字符串的其中一部分执行操作<br /> 对整数和浮点数执行自增或者自减操作</td></tr><tr><td>LIST</td><td>列表</td><td>从两端压入或者弹出元素<br /> 读取单个或者多个元素<br /> 进行修剪，只保留一个范围内的元素</td></tr><tr><td>SET</td><td>无序集合</td><td>添加、获取、移除单个元素<br /> 检查一个元素是否存在于集合中<br /> 计算交集、并集、差集<br /> 从集合里面随机获取元素</td></tr><tr><td>HASH</td><td>包含键值对的无序散列表</td><td>添加、获取、移除单个键值对<br /> 获取所有键值对<br /> 检查某个键是否存在</td></tr><tr><td>ZSET</td><td>有序集合</td><td>添加、获取、删除元素<br /> 根据分值范围或者成员来获取元素<br /> 计算一个键的排名</td></tr></tbody></table><blockquote><p>详细文档：<a href="https://redislabs.com/ebook/part-1-getting-started/chapter-1-getting-to-know-redis/1-2-what-redis-data-structures-look-like/">https://redislabs.com/ebook/part-1-getting-started/chapter-1-getting-to-know-redis/1-2-what-redis-data-structures-look-like/</a></p></blockquote><p><a name="h3_3"></a></p><h3 id="1-2-Redis-的主从复制是如何实现的？"><a href="#1-2-Redis-的主从复制是如何实现的？" class="headerlink" title="1.2. Redis 的主从复制是如何实现的？"></a>1.2. Redis 的主从复制是如何实现的？</h3><ol><li>从服务器连接主服务器，发送 SYNC 命令；</li><li>主服务器接收到 SYNC 命名后，开始执行 BGSAVE 命令生成 RDB 文件并使用缓冲区记录此后执行的所有写命令；</li><li>主服务器 BGSAVE 执行完后，向所有从服务器发送快照文件，并在发送期间继续记录被执行的写命令；</li><li>从服务器收到快照文件后丢弃所有旧数据，载入收到的快照；</li><li>主服务器快照发送完毕后开始向从服务器发送缓冲区中的写命令；</li><li>从服务器完成对快照的载入，开始接收命令请求，并执行来自主服务器缓冲区的写命令；<br><a name="h3_4"></a><h3 id="1-3-Redis-的-key-是如何寻址的？"><a href="#1-3-Redis-的-key-是如何寻址的？" class="headerlink" title="1.3. Redis 的 key 是如何寻址的？"></a>1.3. Redis 的 key 是如何寻址的？</h3><a name="h4_5"></a><h4 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h4><blockquote><p>（1）redis 中的每一个数据库，都由一个 redisDb 的结构存储。其中：</p><ul><li>redisDb.id 存储着 redis 数据库以整数表示的号码。</li><li>redisDb.dict 存储着该库所有的键值对数据。</li><li>redisDb.expires 保存着每一个键的过期时间。</li></ul></blockquote>（2）当 redis 服务器初始化时，会预先分配 16 个数据库（该数量可以通过配置文件配置），所有数据库保存到结构 redisServer<br>的一个成员 redisServer.db 数组中。当我们选择数据库 select number 时，程序直接通过<br>redisServer.db[number] 来切换数据库。有时候当程序需要知道自己是在哪个数据库时，直接读取 redisDb.id 即可。<blockquote><p>（3）redis 的字典使用哈希表作为其底层实现。dict 类型使用的两个指向哈希表的指针，其中 0<br>号哈希表（ht[0]）主要用于存储数据库的所有键值，而 1 号哈希表主要用于程序对 0 号哈希表进行 rehash 时使用，rehash<br>一般是在添加新值时会触发，这里不做过多的赘述。所以 redis 中查找一个 key，其实就是对进行该 dict 结构中的 ht[0]<br>进行查找操作。<br>（4）既然是哈希，那么我们知道就会有哈希碰撞，那么当多个键哈希之后为同一个值怎么办呢？redis<br>采取链表的方式来存储多个哈希碰撞的键。也就是说，当根据 key 的哈希值找到该列表后，如果列表的长度大于<br>1，那么我们需要遍历该链表来找到我们所查找的 key。当然，一般情况下链表长度都为是 1，所以时间复杂度可看作 o(1)。</p></blockquote></li></ol><p><a name="h4_6"></a></p><h4 id="寻址-key-的步骤"><a href="#寻址-key-的步骤" class="headerlink" title="寻址 key 的步骤"></a>寻址 key 的步骤</h4><blockquote><ol><li>当拿到一个 key 后，redis 先判断当前库的 0 号哈希表是否为空，即：if (dict-&gt;ht[0].size == 0)。如果为 true 直接返回 NULL。</li><li>判断该 0 号哈希表是否需要 rehash，因为如果在进行 rehash，那么两个表中者有可能存储该 key。如果正在进行<br>rehash，将调用一次_dictRehashStep 方法，_dictRehashStep 用于对数据库字典、以及哈希键的字典进行被动<br>rehash，这里不作赘述。</li><li>计算哈希表，根据当前字典与 key 进行哈希值的计算。</li><li>根据哈希值与当前字典计算哈希表的索引值。</li><li>根据索引值在哈希表中取出链表，遍历该链表找到 key 的位置。一般情况，该链表长度为 1。</li><li>当 ht[0] 查找完了之后，再进行了次 rehash 判断，如果未在 rehashing，则直接结束，否则对 ht[1]重复 345 步骤。</li></ol></blockquote><p><a name="h3_7"></a></p><h3 id="1-4-Redis-的集群模式是如何实现的？"><a href="#1-4-Redis-的集群模式是如何实现的？" class="headerlink" title="1.4. Redis 的集群模式是如何实现的？"></a><strong>1.4. Redis 的集群模式是如何实现的？</strong></h3><blockquote><p>Redis Cluster 是 Redis 的分布式解决方案，在 Redis 3.0 版本正式推出的。<br>Redis Cluster 去中心化，每个节点保存数据和整个集群状态，每个节点都和其他所有节点连接。</p></blockquote><p><a name="h4_8"></a></p><h4 id="Redis-Cluster-节点分配"><a href="#Redis-Cluster-节点分配" class="headerlink" title="Redis Cluster 节点分配"></a>Redis Cluster 节点分配</h4><blockquote><p>Redis Cluster 特点：</p><ol><li>所有的 redis 节点彼此互联(PING-PONG 机制)，内部使用二进制协议优化传输速度和带宽。</li><li>节点的 fail 是通过集群中超过半数的节点检测失效时才生效。</li><li>客户端与 redis 节点直连,不需要中间 proxy 层。客户端不需要连接集群所有节点，连接集群中任何一个可用节点即可。</li><li>redis-cluster 把所有的物理节点映射到[0-16383] 哈希槽 (hash slot)上（不一定是平均分配）,cluster 负责维护 node、slot、value。</li><li>Redis 集群预分好 16384 个桶，当需要在 Redis 集群中放置一个 key-value 时，根据 CRC16(key) mod 16384 的值，决定将一个 key 放到哪个桶中。</li></ol></blockquote><p><a name="h4_9"></a></p><h4 id="Redis-Cluster-主从模式"><a href="#Redis-Cluster-主从模式" class="headerlink" title="Redis Cluster 主从模式"></a>Redis Cluster 主从模式</h4><blockquote><p>Redis Cluster 为了保证数据的高可用性，加入了主从模式。<br>一个主节点对应一个或多个从节点，主节点提供数据存取，从节点则是从主节点拉取数据备份。当这个主节点挂掉后，就会有这个从节点选取一个来充当主节点，从而保证集群不会挂掉。所以，在集群建立的时候，一定要为每个主节点都添加了从节点。</p></blockquote><p><a name="h4_10"></a></p><h4 id="Redis-Sentinel"><a href="#Redis-Sentinel" class="headerlink" title="Redis Sentinel"></a>Redis Sentinel</h4><blockquote><p>Redis Sentinel 用于管理多个 Redis 服务器，它有三个功能：</p><ul><li><strong>监控（Monitoring）</strong> - Sentinel 会不断地检查你的主服务器和从服务器是否运作正常。</li><li><strong>提醒（Notification）</strong> - 当被监控的某个 Redis 服务器出现问题时， Sentinel 可以通过 API 向管理员或者其他应用程序发送通知。</li><li><strong>自动故障迁移（Automatic failover）</strong> - 当一个主服务器不能正常工作时，<br>Sentinel 会开始一次自动故障迁移操作， 它会将失效主服务器的其中一个从服务器升级为新的主服务器，<br>并让失效主服务器的其他从服务器改为复制新的主服务器； 当客户端试图连接失效的主服务器时， 集群也会向客户端返回新主服务器的地址，<br>使得集群可以使用新主服务器代替失效服务器。 </li></ul></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Redis 集群中应该有奇数个节点，所以至少有三个节点。</span><br><span class="line">哨兵监控集群中的主服务器出现故障时，需要根据 quorum 选举出一个哨兵来执行故障转移。选举需要 </span><br><span class="line">majority，即大多数哨兵是运行的（2 个哨兵的 majority&#x3D;2，3 个哨兵的 majority&#x3D;2，5 个哨兵的 </span><br><span class="line">majority&#x3D;3，4 个哨兵的 majority&#x3D;2）。</span><br><span class="line">假设集群仅仅部署 2 个节点</span><br><span class="line">+----+         +----+</span><br><span class="line">| M1 |---------| R1 |</span><br><span class="line">| S1 |         | S2 |</span><br><span class="line">+----+         +----+</span><br><span class="line">如果 M1 和 S1 所在服务器宕机，则哨兵只有 1 个，无法满足 majority 来进行选举，就不能执行故障转移。</span><br></pre></td></tr></table></figure><br /><p><a name="h3_11"></a></p><h3 id="1-5-Redis-如何实现分布式锁？ZooKeeper-如何实现分布式锁？比较二者优劣？"><a href="#1-5-Redis-如何实现分布式锁？ZooKeeper-如何实现分布式锁？比较二者优劣？" class="headerlink" title="1.5. Redis 如何实现分布式锁？ZooKeeper 如何实现分布式锁？比较二者优劣？"></a>1.5. Redis 如何实现分布式锁？ZooKeeper 如何实现分布式锁？比较二者优劣？</h3><blockquote><p>分布式锁的三种实现：</p><ul><li>基于数据库实现分布式锁；</li><li>基于缓存（Redis 等）实现分布式锁；</li><li>基于 Zookeeper 实现分布式锁；</li></ul></blockquote><p><a name="h4_12"></a></p><h4 id="数据库实现"><a href="#数据库实现" class="headerlink" title="数据库实现"></a>数据库实现</h4><p><a name="h4_13"></a></p><h4 id="Redis-实现"><a href="#Redis-实现" class="headerlink" title="Redis 实现"></a><strong>Redis 实现</strong></h4><blockquote><ol><li>获取锁的时候，使用 setnx 加锁，并使用 expire 命令为锁添加一个超时时间，超过该时间则自动释放锁，锁的 value 值为一个随机生成的 UUID，通过此在释放锁的时候进行判断。</li><li>获取锁的时候还设置一个获取的超时时间，若超过这个时间则放弃获取锁。</li><li>释放锁的时候，通过 UUID 判断是不是该锁，若是该锁，则执行 delete 进行锁释放。</li></ol></blockquote> <br /><p><a name="h4_14"></a></p><h4 id="ZooKeeper-实现"><a href="#ZooKeeper-实现" class="headerlink" title="ZooKeeper 实现"></a><strong>ZooKeeper 实现</strong></h4><blockquote><ol><li>创建一个目录 mylock；</li><li>线程 A 想获取锁就在 mylock 目录下创建临时顺序节点；</li><li>获取 mylock 目录下所有的子节点，然后获取比自己小的兄弟节点，如果不存在，则说明当前线程顺序号最小，获得锁；</li><li>线程 B 获取所有节点，判断自己不是最小节点，设置监听比自己次小的节点；</li><li>线程 A 处理完，删除自己的节点，线程 B 监听到变更事件，判断自己是不是最小的节点，如果是则获得锁。</li></ol></blockquote><p><a name="h4_15"></a></p><h4 id="实现对比"><a href="#实现对比" class="headerlink" title="实现对比"></a>实现对比</h4><blockquote><p>ZooKeeper 具备高可用、可重入、阻塞锁特性，可解决失效死锁问题。 但 ZooKeeper 因为需要频繁的创建和删除节点，性能上不如 Redis 方式。</p></blockquote><p><a name="h3_16"></a></p><h3 id="1-6-Redis-的持久化方式？有什么优缺点？持久化实现原理？"><a href="#1-6-Redis-的持久化方式？有什么优缺点？持久化实现原理？" class="headerlink" title="1.6. Redis 的持久化方式？有什么优缺点？持久化实现原理？"></a><strong>1.6. Redis 的持久化方式？有什么优缺点？持久化实现原理？</strong></h3><p><a name="h4_17"></a></p><h4 id="RDB-快照（snapshot）"><a href="#RDB-快照（snapshot）" class="headerlink" title="RDB 快照（snapshot）"></a>RDB 快照（snapshot）</h4><blockquote><p>将存在于某一时刻的所有数据都写入到硬盘中。<br>快照的原理<br>在默认情况下，Redis 将数据库快照保存在名字为 dump.rdb 的二进制文件中。你可以对 Redis 进行设置， 让它在“N<br>秒内数据集至少有 M 个改动”这一条件被满足时， 自动保存一次数据集。你也可以通过调用 SAVE 或者 BGSAVE，手动让 Redis<br>进行数据集保存操作。这种持久化方式被称为快照。<br>当 Redis 需要保存 dump.rdb 文件时， 服务器执行以下操作:</p><ul><li>Redis 创建一个子进程。</li><li>子进程将数据集写入到一个临时快照文件中。</li><li>当子进程完成对新快照文件的写入时，Redis 用新快照文件替换原来的快照文件，并删除旧的快照文件。</li></ul></blockquote><p>这种工作方式使得 Redis 可以从写时复制（copy-on-write）机制中获益。</p><blockquote><p>快照的优点</p><ul><li>它保存了某个时间点的数据集，非常适用于数据集的备份。</li><li>很方便传送到另一个远端数据中心或者亚马逊的 S3（可能加密），非常适用于灾难恢复。</li><li>快照在保存 RDB 文件时父进程唯一需要做的就是 fork 出一个子进程，接下来的工作全部由子进程来做，父进程不需要再做其他 IO 操作，所以快照持久化方式可以最大化 redis 的性能。</li><li>与 AOF 相比，在恢复大的数据集的时候，DB 方式会更快一些。</li></ul></blockquote><p>快照的缺点</p><blockquote><ul><li>如果你希望在 redis 意外停止工作（例如电源中断）的情况下丢失的数据最少的话，那么快照不适合你。</li><li>快照需要经常 fork 子进程来保存数据集到硬盘上。当数据集比较大的时候，fork 的过程是非常耗时的，可能会导致 Redis 在一些毫秒级内不能响应客户端的请求。</li></ul></blockquote><p><a name="h4_18"></a></p><h4 id="AOF"><a href="#AOF" class="headerlink" title="AOF"></a>AOF</h4><blockquote><p>AOF 持久化方式记录每次对服务器执行的写操作。当服务器重启的时候会重新执行这些命令来恢复原始的数据。</p></blockquote> <br /><p><a name="h4_19"></a></p><h4 id="AOF-的原理"><a href="#AOF-的原理" class="headerlink" title="AOF 的原理"></a>AOF 的原理</h4><blockquote><ul><li>Redis 创建一个子进程。</li><li>子进程开始将新 AOF 文件的内容写入到临时文件。</li><li>对于所有新执行的写入命令，父进程一边将它们累积到一个内存缓存中，一边将这些改动追加到现有 AOF 文件的末尾，这样样即使在重写的中途发生停机，现有的 AOF 文件也还是安全的。</li><li>当子进程完成重写工作时，它给父进程发送一个信号，父进程在接收到信号之后，将内存缓存中的所有数据追加到新 AOF 文件的末尾。</li><li>搞定！现在 Redis 原子地用新文件替换旧文件，之后所有命令都会直接追加到新 AOF 文件的末尾。</li></ul></blockquote> <br /><p><a name="h4_20"></a></p><h4 id="AOF-的优点"><a href="#AOF-的优点" class="headerlink" title="AOF 的优点"></a>AOF 的优点</h4><blockquote><ul><li>使用默认的每秒 fsync 策略，Redis 的性能依然很好(fsync 是由后台线程进行处理的,主线程会尽力处理客户端请求)，一旦出现故障，使用 AOF ，你最多丢失 1 秒的数据。</li><li>AOF 文件是一个只进行追加的日志文件，所以不需要写入 seek，即使由于某些原因(磁盘空间已满，写的过程中宕机等等)未执行完整的写入命令，你也也可使用 redis-check-aof 工具修复这些问题。</li><li>Redis 可以在 AOF 文件体积变得过大时，自动地在后台对 AOF 进行重写：重写后的新 AOF 文件包含了恢复当前数据集所需的最小命令集合。整个重写操作是绝对安全的。</li><li>AOF 文件有序地保存了对数据库执行的所有写入操作，这些写入操作以 Redis 协议的格式保存。因此 AOF 文件的内容非常容易被人读懂，对文件进行分析（parse）也很轻松。</li></ul></blockquote> <br /><p><a name="h4_21"></a></p><h4 id="AOF-的缺点"><a href="#AOF-的缺点" class="headerlink" title="AOF 的缺点"></a>AOF 的缺点</h4><blockquote><ul><li>对于相同的数据集来说，AOF 文件的体积通常要大于 RDB 文件的体积。</li><li>根据所使用的 fsync 策略，AOF 的速度可能会慢于快照。在一般情况下，每秒 fsync 的性能依然非常高，而关闭 fsync<br>可以让 AOF 的速度和快照一样快，即使在高负荷之下也是如此。不过在处理巨大的写入载入时，快照可以提供更有保证的最大延迟时间（latency）。</li></ul></blockquote> <br /><p><a name="h3_22"></a></p><h3 id="1-7-Redis-过期策略有哪些？"><a href="#1-7-Redis-过期策略有哪些？" class="headerlink" title="1.7. Redis 过期策略有哪些？"></a>1.7. Redis 过期策略有哪些？</h3><blockquote><ul><li><strong>noeviction</strong> - 当内存使用达到阈值的时候，所有引起申请内存的命令会报错。</li><li><strong>allkeys-lru</strong> - 在主键空间中，优先移除最近未使用的 key。</li><li><strong>allkeys-random</strong> - 在主键空间中，随机移除某个 key。</li><li><strong>volatile-lru</strong> - 在设置了过期时间的键空间中，优先移除最近未使用的 key。</li><li><strong>volatile-random</strong> - 在设置了过期时间的键空间中，随机移除某个 key。</li><li><strong>volatile-ttl</strong> - 在设置了过期时间的键空间中，具有更早过期时间的 key 优先移除。</li></ul></blockquote> <br /><p><a name="h3_23"></a></p><h3 id="1-8-Redis-和-Memcached-有什么区别？"><a href="#1-8-Redis-和-Memcached-有什么区别？" class="headerlink" title="1.8. Redis 和 Memcached 有什么区别？"></a>1.8. Redis 和 Memcached 有什么区别？</h3><blockquote><p>两者都是非关系型内存键值数据库。有以下主要不同：<br><strong>数据类型</strong></p><ul><li>Memcached 仅支持字符串类型；</li><li>而 Redis 支持五种不同种类的数据类型，使得它可以更灵活地解决问题。</li></ul></blockquote><p><strong>数据持久化</strong></p><blockquote><ul><li>Memcached 不支持持久化；</li><li>Redis 支持两种持久化策略：RDB 快照和 AOF 日志。</li></ul></blockquote><p><strong>分布式</strong></p><blockquote><ul><li>Memcached 不支持分布式，只能通过在客户端使用像一致性哈希这样的分布式算法来实现分布式存储，这种方式在存储和查询时都需要先在客户端计算一次数据所在的节点。</li><li>Redis Cluster 实现了分布式的支持。</li></ul></blockquote><p><strong>内存管理机制</strong></p><blockquote><ul><li>Memcached 将内存分割成特定长度的块来存储数据，以完全解决内存碎片的问题，但是这种方式会使得内存的利用率不高，例如块的大小为 128 bytes，只存储 100 bytes 的数据，那么剩下的 28 bytes 就浪费掉了。</li><li>在 Redis 中，并不是所有数据都一直存储在内存中，可以将一些很久没用的 value 交换到磁盘。而 Memcached 的数据则会一直在内存中。</li></ul></blockquote> <br /><p><a name="h3_24"></a></p><h3 id="1-9-为什么单线程的-Redis-性能反而优于多线程的-Memcached？"><a href="#1-9-为什么单线程的-Redis-性能反而优于多线程的-Memcached？" class="headerlink" title="1.9. 为什么单线程的 Redis 性能反而优于多线程的 Memcached？"></a>1.9. 为什么单线程的 Redis 性能反而优于多线程的 Memcached？</h3><blockquote><p>Redis 快速的原因：</p><ol><li>绝大部分请求是纯粹的内存操作（非常快速）</li><li>采用单线程,避免了不必要的上下文切换和竞争条件</li><li>非阻塞 IO</li></ol></blockquote><p>内部实现采用 epoll，采用了 epoll+自己实现的简单的事件框架。epoll 中的读、写、关闭、连接都转化成了事件，然后利用 epoll 的多路复用特性，绝不在 io 上浪费一点时间。</p><p><a name="h2_25"></a></p><h2 id="2-分布式消息队列（MQ）"><a href="#2-分布式消息队列（MQ）" class="headerlink" title="2. 分布式消息队列（MQ）"></a>2. 分布式消息队列（MQ）</h2><p><a name="h3_26"></a></p><h3 id="2-1-为什么使用-MQ？"><a href="#2-1-为什么使用-MQ？" class="headerlink" title="2.1. 为什么使用 MQ？"></a>2.1. 为什么使用 MQ？</h3><blockquote><ul><li>异步处理 - 相比于传统的串行、并行方式，提高了系统吞吐量。</li><li>应用解耦 - 系统间通过消息通信，不用关心其他系统的处理。</li><li>流量削锋 - 可以通过消息队列长度控制请求量；可以缓解短时间内的高并发请求。</li><li>日志处理 - 解决大量日志传输。</li><li>消息通讯 - 消息队列一般都内置了高效的通信机制，因此也可以用在纯的消息通讯。比如实现点对点消息队列，或者聊天室等。</li></ul></blockquote> <br /><p><a name="h3_27"></a></p><h3 id="2-2-如何保证-MQ-的高可用？"><a href="#2-2-如何保证-MQ-的高可用？" class="headerlink" title="2.2. 如何保证 MQ 的高可用？"></a>2.2. 如何保证 MQ 的高可用？</h3><p><a name="h4_28"></a></p><h4 id="数据复制"><a href="#数据复制" class="headerlink" title="数据复制"></a>数据复制</h4><blockquote><ol><li>将所有 Broker 和待分配的 Partition 排序</li><li>将第 i 个 Partition 分配到第（i mod n）个 Broker 上</li><li>将第 i 个 Partition 的第 j 个 Replica 分配到第（(i + j) mode n）个 Broker 上</li></ol></blockquote><p><a name="h4_29"></a></p><h4 id="选举主服务器"><a href="#选举主服务器" class="headerlink" title="选举主服务器"></a>选举主服务器</h4> <br /><p><a name="h3_30"></a></p><h3 id="2-3-MQ-有哪些常见问题？如何解决这些问题？"><a href="#2-3-MQ-有哪些常见问题？如何解决这些问题？" class="headerlink" title="2.3. MQ 有哪些常见问题？如何解决这些问题？"></a>2.3. MQ 有哪些常见问题？如何解决这些问题？</h3><blockquote><p>MQ 的常见问题有：</p><ol><li>消息的顺序问题</li><li>消息的重复问题</li></ol></blockquote><p><a name="h4_31"></a></p><h4 id="消息的顺序问题"><a href="#消息的顺序问题" class="headerlink" title="消息的顺序问题"></a>消息的顺序问题</h4><blockquote><p>消息有序指的是可以按照消息的发送顺序来消费。<br>假如生产者产生了 2 条消息：M1、M2，假定 M1 发送到 S1，M2 发送到 S2，如果要保证 M1 先于 M2 被消费，怎么做？</p></blockquote><p> <br /><img src="https://cdn.nlark.com/yuque/0/2020/jpeg/360514/1587442953361-a546fc90-486c-4507-8bee-0929a00c8e77.jpeg#align=left&display=inline&height=306&margin=%5Bobject%20Object%5D&originHeight=306&originWidth=640&size=0&status=done&style=none&width=640" alt=""><br /> <br /> </p><blockquote><p>解决方案：<br>（1）保证生产者 - MQServer - 消费者是一对一对一的关系</p></blockquote><p> <br /><img src="https://cdn.nlark.com/yuque/0/2020/jpeg/360514/1587442953394-b5b4cda3-c5bb-4a6c-8631-22345cfd948d.jpeg#align=left&display=inline&height=301&margin=%5Bobject%20Object%5D&originHeight=301&originWidth=640&size=0&status=done&style=none&width=640" alt=""><br /> <br /> </p><blockquote><p>缺陷：</p><ul><li>并行度就会成为消息系统的瓶颈（吞吐量不够）</li><li>更多的异常处理，比如：只要消费端出现问题，就会导致整个处理流程阻塞，我们不得不花费更多的精力来解决阻塞的问题。</li></ul></blockquote><p>（2）通过合理的设计或者将问题分解来规避。</p><blockquote><ul><li>不关注乱序的应用实际大量存在</li><li>队列无序并不意味着消息无序</li></ul></blockquote><p>所以从业务层面来保证消息的顺序而不仅仅是依赖于消息系统，是一种更合理的方式。</p><p><a name="h4_32"></a></p><h4 id="消息的重复问题"><a href="#消息的重复问题" class="headerlink" title="消息的重复问题"></a><strong>消息的重复问题</strong></h4><blockquote><p>造成消息重复的根本原因是：网络不可达。<br>所以解决这个问题的办法就是绕过这个问题。那么问题就变成了：如果消费端收到两条一样的消息，应该怎样处理？<br>消费端处理消息的业务逻辑保持幂等性。只要保持幂等性，不管来多少条重复消息，最后处理的结果都一样。<br>保证每条消息都有唯一编号且保证消息处理成功与去重表的日志同时出现。利用一张日志表来记录已经处理成功的消息的 ID，如果新到的消息 ID<br>已经在日志表中，那么就不再处理这条消息。</p></blockquote><p><a name="h3_33"></a></p><h3 id="2-4-Kafka-ActiveMQ-RabbitMQ-RocketMQ-各有什么优缺点？"><a href="#2-4-Kafka-ActiveMQ-RabbitMQ-RocketMQ-各有什么优缺点？" class="headerlink" title="2.4. Kafka, ActiveMQ, RabbitMQ, RocketMQ 各有什么优缺点？"></a>2.4. Kafka, ActiveMQ, RabbitMQ, RocketMQ 各有什么优缺点？</h3><p> <br /><img src="https://cdn.nlark.com/yuque/0/2020/jpeg/360514/1587442953553-5107de60-2f94-4e57-83f3-d1fcbabd1b39.jpeg#align=left&display=inline&height=854&margin=%5Bobject%20Object%5D&originHeight=854&originWidth=934&size=0&status=done&style=none&width=934" alt=""><br /></p><p><a name="h2_34"></a></p><h2 id="3-分布式服务（RPC）"><a href="#3-分布式服务（RPC）" class="headerlink" title="3. 分布式服务（RPC）"></a>3. 分布式服务（RPC）</h2><p><a name="h3_35"></a></p><h3 id="3-1-Dubbo-的实现过程？"><a href="#3-1-Dubbo-的实现过程？" class="headerlink" title="3.1. Dubbo 的实现过程？"></a>3.1. Dubbo 的实现过程？</h3><p><img src="https://cdn.nlark.com/yuque/0/2020/png/360514/1587442953411-aab0330d-450f-4ace-8a08-112bb5ed9a21.png#align=left&display=inline&height=312&margin=%5Bobject%20Object%5D&originHeight=670&originWidth=1074&size=0&status=done&style=none&width=500" alt=""><br />节点角色：</p><table><thead><tr><th>节点</th><th>角色说明</th></tr></thead><tbody><tr><td>Provider</td><td>暴露服务的服务提供方</td></tr><tr><td>Consumer</td><td>调用远程服务的服务消费方</td></tr><tr><td>Registry</td><td>服务注册与发现的注册中心</td></tr><tr><td>Monitor</td><td>统计服务的调用次数和调用时间的监控中心</td></tr><tr><td>Container</td><td>服务运行容器</td></tr></tbody></table><blockquote><p>调用关系：</p><ol><li>务容器负责启动，加载，运行服务提供者。</li><li>服务提供者在启动时，向注册中心注册自己提供的服务。</li><li>服务消费者在启动时，向注册中心订阅自己所需的服务。</li><li>注册中心返回服务提供者地址列表给消费者，如果有变更，注册中心将基于长连接推送变更数据给消费者。</li><li>服务消费者，从提供者地址列表中，基于软负载均衡算法，选一台提供者进行调用，如果调用失败，再选另一台调用。</li><li>服务消费者和提供者，在内存中累计调用次数和调用时间，定时每分钟发送一次统计数据到监控中心。</li></ol></blockquote> <br /><p><a name="h3_36"></a></p><h3 id="3-2-Dubbo-负载均衡策略有哪些？"><a href="#3-2-Dubbo-负载均衡策略有哪些？" class="headerlink" title="3.2. Dubbo 负载均衡策略有哪些？"></a>3.2. Dubbo 负载均衡策略有哪些？</h3><p><a name="AODjV"></a></p><h4 id="Random"><a href="#Random" class="headerlink" title="Random"></a>Random</h4><blockquote><ul><li>随机，按权重设置随机概率。</li><li>在一个截面上碰撞的概率高，但调用量越大分布越均匀，而且按概率使用权重后也比较均匀，有利于动态调整提供者权重。</li></ul></blockquote><p><a name="0ii15"></a></p><h4 id="RoundRobin"><a href="#RoundRobin" class="headerlink" title="RoundRobin"></a>RoundRobin</h4><blockquote><ul><li>轮循，按公约后的权重设置轮循比率。</li><li>存在慢的提供者累积请求的问题，比如：第二台机器很慢，但没挂，当请求调到第二台时就卡在那，久而久之，所有请求都卡在调到第二台上。</li></ul></blockquote><p><a name="EztHn"></a></p><h4 id="LeastActive"><a href="#LeastActive" class="headerlink" title="LeastActive"></a>LeastActive</h4><blockquote><ul><li>最少活跃调用数，相同活跃数的随机，活跃数指调用前后计数差。</li><li>使慢的提供者收到更少请求，因为越慢的提供者的调用前后计数差会越大。</li></ul></blockquote><p><a name="iymve"></a></p><h4 id="ConsistentHash"><a href="#ConsistentHash" class="headerlink" title="ConsistentHash"></a>ConsistentHash</h4><blockquote><ul><li>一致性 Hash，相同参数的请求总是发到同一提供者。</li><li>当某一台提供者挂时，原本发往该提供者的请求，基于虚拟节点，平摊到其它提供者，不会引起剧烈变动。</li><li>缺省只对第一个参数 Hash，如果要修改，请配置 <code>&lt;dubbo:parameter key=&quot;hash.arguments&quot; value=&quot;0,1&quot; /&gt;</code></li><li>缺省用 160 份虚拟节点，如果要修改，请配置 <code>&lt;dubbo:parameter key=&quot;hash.nodes&quot; value=&quot;320&quot; /&gt;</code></li></ul></blockquote> <br /><p><a name="h3_37"></a></p><h3 id="3-3-Dubbo-集群容错策略-？"><a href="#3-3-Dubbo-集群容错策略-？" class="headerlink" title="3.3. Dubbo 集群容错策略 ？"></a>3.3. Dubbo 集群容错策略 ？</h3><p> <br /><img src="https://cdn.nlark.com/yuque/0/2020/jpeg/360514/1587442953525-3c5cad00-e450-4a6d-9a4e-1b90b5fa1cb7.jpeg#align=left&display=inline&height=300&margin=%5Bobject%20Object%5D&originHeight=300&originWidth=600&size=0&status=done&style=none&width=600" alt=""><br /> </p><blockquote><ul><li><strong>Failover</strong> - 失败自动切换，当出现失败，重试其它服务器。通常用于读操作，但重试会带来更长延迟。可通过 retries=”2” 来设置重试次数(不含第一次)。</li><li><strong>Failfast</strong> - 快速失败，只发起一次调用，失败立即报错。通常用于非幂等性的写操作，比如新增记录。</li><li><strong>Failsafe</strong> - 失败安全，出现异常时，直接忽略。通常用于写入审计日志等操作。</li><li><strong>Failback</strong> - 失败自动恢复，后台记录失败请求，定时重发。通常用于消息通知操作。</li><li><strong>Forking</strong> - 并行调用多个服务器，只要一个成功即返回。通常用于实时性要求较高的读操作，但需要浪费更多服务资源。可通过 forks=”2” 来设置最大并行数。</li><li><strong>Broadcast</strong> - 播调用所有提供者，逐个调用，任意一台报错则报错。通常用于通知所有提供者更新缓存或日志等本地资源信息。</li></ul></blockquote> <br /><p><a name="h3_38"></a></p><h3 id="3-4-动态代理策略？"><a href="#3-4-动态代理策略？" class="headerlink" title="3.4. 动态代理策略？"></a>3.4. 动态代理策略？</h3><blockquote><p>Dubbo 作为 RPC 框架，首先要完成的就是跨系统，跨网络的服务调用。消费方与提供方遵循统一的接口定义，消费方调用接口时，Dubbo<br>将其转换成统一格式的数据结构，通过网络传输，提供方根据规则找到接口实现，通过反射完成调用。也就是说，消费方获取的是对远程服务的一个代理(Proxy)，而提供方因为要支持不同的接口实现，需要一个包装层(Wrapper)。调用的过程大概是这样：</p></blockquote><p> <br /><img src="https://cdn.nlark.com/yuque/0/2020/png/360514/1587442953362-bf3d7b9f-f7e2-4113-82ca-5dbbecde6891.png#align=left&display=inline&height=145&margin=%5Bobject%20Object%5D&originHeight=145&originWidth=655&size=0&status=done&style=none&width=655" alt=""><br /> <br /> </p><blockquote><p>消费方的 Proxy 和提供方的 Wrapper 得以让 Dubbo 构建出复杂、统一的体系。而这种动态代理与包装也是通过基于 SPI 的插件方式实现的，它的接口就是<strong>ProxyFactory</strong>。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SPI</span>(<span class="string">"javassist"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ProxyFactory</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Adaptive</span>(&#123;Constants.PROXY_KEY&#125;)</span><br><span class="line">    &lt;T&gt; <span class="function">T <span class="title">getProxy</span><span class="params">(Invoker&lt;T&gt; invoker)</span> <span class="keyword">throws</span> RpcException</span>;</span><br><span class="line">    <span class="meta">@Adaptive</span>(&#123;Constants.PROXY_KEY&#125;)</span><br><span class="line">    &lt;T&gt; <span class="function">Invoker&lt;T&gt; <span class="title">getInvoker</span><span class="params">(T proxy, Class&lt;T&gt; type, URL url)</span> <span class="keyword">throws</span> RpcException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>ProxyFactory 有两种实现方式，一种是基于 JDK 的代理实现，一种是基于 javassist 的实现。ProxyFactory 接口上定义了@SPI(“javassist”)，默认为 javassist 的实现。</p></blockquote> <br /><p><a name="h3_39"></a></p><h3 id="3-5-Dubbo-支持哪些序列化协议？Hessian？Hessian-的数据结构？"><a href="#3-5-Dubbo-支持哪些序列化协议？Hessian？Hessian-的数据结构？" class="headerlink" title="3.5. Dubbo 支持哪些序列化协议？Hessian？Hessian 的数据结构？"></a>3.5. Dubbo 支持哪些序列化协议？Hessian？Hessian 的数据结构？</h3><blockquote><ol><li>dubbo 序列化，阿里尚不成熟的 java 序列化实现。</li><li>hessian2 序列化：hessian 是一种跨语言的高效二进制的序列化方式，但这里实际不是原生的 hessian2 序列化，而是阿里修改过的 hessian lite，它是 dubbo RPC 默认启用的序列化方式。</li><li>json 序列化：目前有两种实现，一种是采用的阿里的 fastjson 库，另一种是采用 dubbo 中自已实现的简单 json 库，一般情况下，json 这种文本序列化性能不如二进制序列化。</li><li>java 序列化：主要是采用 JDK 自带的 java 序列化实现，性能很不理想。</li><li>Kryo 和 FST：Kryo 和 FST 的性能依然普遍优于 hessian 和 dubbo 序列化。</li></ol></blockquote><p>Hessian 序列化与 Java 默认的序列化区别？</p><blockquote><p>Hessian 是一个轻量级的 remoting on http 工具，采用的是 Binary RPC 协议，所以它很适合于发送二进制数据，同时又具有防火墙穿透能力。</p><ol><li>Hessian 支持跨语言串行</li><li>比 java 序列化具有更好的性能和易用性</li><li>支持的语言比较多</li></ol></blockquote> <br /><p><a name="h3_40"></a></p><h3 id="3-6-Protoco-Buffer-是什么？"><a href="#3-6-Protoco-Buffer-是什么？" class="headerlink" title="3.6. Protoco Buffer 是什么？"></a>3.6. Protoco Buffer 是什么？</h3><blockquote><p>Protocol Buffer 是 Google 出品的一种轻量 &amp; 高效的结构化数据存储格式，性能比 Json、XML 真的强！太！多！<br>Protocol Buffer 的序列化 &amp; 反序列化简单 &amp; 速度快的原因是：</p><ol><li>编码 / 解码 方式简单（只需要简单的数学运算 = 位移等等）</li><li>采用 Protocol Buffer 自身的框架代码 和 编译器 共同完成</li></ol></blockquote><p>Protocol Buffer 的数据压缩效果好（即序列化后的数据量体积小）的原因是：</p><blockquote><ol><li>采用了独特的编码方式，如 Varint、Zigzag 编码方式等等</li><li>采用 T - L - V 的数据存储方式：减少了分隔符的使用 &amp; 数据存储得紧凑</li></ol></blockquote> <br /><p><a name="h3_41"></a></p><h3 id="3-7-注册中心挂了可以继续通信吗？"><a href="#3-7-注册中心挂了可以继续通信吗？" class="headerlink" title="3.7. 注册中心挂了可以继续通信吗？"></a>3.7. 注册中心挂了可以继续通信吗？</h3><blockquote><p>可以。Dubbo 消费者在应用启动时会从注册中心拉取已注册的生产者的地址接口，并缓存在本地。每次调用时，按照本地存储的地址进行调用。</p></blockquote> <br /><p><a name="h3_42"></a></p><h3 id="3-8-ZooKeeper-原理是什么？ZooKeeper-有什么用？"><a href="#3-8-ZooKeeper-原理是什么？ZooKeeper-有什么用？" class="headerlink" title="3.8. ZooKeeper 原理是什么？ZooKeeper 有什么用？"></a>3.8. ZooKeeper 原理是什么？ZooKeeper 有什么用？</h3><blockquote><p>ZooKeeper 是一个分布式应用协调系统，已经用到了许多分布式项目中，用来完成统一命名服务、状态同步服务、集群管理、分布式应用配置项的管理等工作。</p></blockquote><p><img src="https://cdn.nlark.com/yuque/0/2020/png/360514/1587442953420-fd764b66-521d-4327-9e47-42998be0d0ae.png#align=left&display=inline&height=179&margin=%5Bobject%20Object%5D&originHeight=179&originWidth=572&size=0&status=done&style=none&width=572" alt=""></p><blockquote><ol><li>每个 Server 在内存中存储了一份数据；</li><li>Zookeeper 启动时，将从实例中选举一个 leader（Paxos 协议）；</li><li>Leader 负责处理数据更新等操作（Zab 协议）；</li><li>一个更新操作成功，当且仅当大多数 Server 在内存中成功修改数据。</li></ol></blockquote> <br /><p><a name="h3_43"></a></p><h3 id="3-9-Netty-有什么用？NIO-BIO-AIO-有什么用？有什么区别？"><a href="#3-9-Netty-有什么用？NIO-BIO-AIO-有什么用？有什么区别？" class="headerlink" title="3.9. Netty 有什么用？NIO/BIO/AIO 有什么用？有什么区别？"></a>3.9. Netty 有什么用？NIO/BIO/AIO 有什么用？有什么区别？</h3><blockquote><p>Netty 是一个“网络通讯框架”。<br>Netty 进行事件处理的流程。<code>Channel</code>是连接的通道，是 ChannelEvent 的产生者，而<code>ChannelPipeline</code>可以理解为 ChannelHandler 的集合。</p></blockquote><p> <br /><img src="https://cdn.nlark.com/yuque/0/2020/png/360514/1587442953365-763fb0e2-dc81-4bb7-b1da-6369a77b4195.png#align=left&display=inline&height=356&margin=%5Bobject%20Object%5D&originHeight=356&originWidth=437&size=0&status=done&style=none&width=437" alt=""><br /> </p><blockquote><p>IO 的方式通常分为几种：</p><ul><li>同步阻塞的 BIO</li><li>同步非阻塞的 NIO</li><li>异步非阻塞的 AIO</li></ul></blockquote><p>在使用同步 I/O 的网络应用中，如果要同时处理多个客户端请求，或是在客户端要同时和多个服务器进行通讯，就必须使用多线程来处理。</p><blockquote><p>NIO 基于 Reactor，当 socket 有流可读或可写入 socket<br>时，操作系统会相应的通知引用程序进行处理，应用再将流读取到缓冲区或写入操作系统。也就是说，这个时候，已经不是一个连接就要对应一个处理线程了，而是有效的请求，对应一个线程，当连接没有数据时，是没有工作线程来处理的。<br>与 NIO 不同，当进行读写操作时，只须直接调用 API 的 read 或 write<br>方法即可。这两种方法均为异步的，对于读操作而言，当有流可读取时，操作系统会将可读的流传入 read<br>方法的缓冲区，并通知应用程序；对于写操作而言，当操作系统将 write 方法传递的流写入完毕时，操作系统主动通知应用程序。<br>即可以理解为，read/write 方法都是异步的，完成后会主动调用回调函数。</p></blockquote> <br /><p><a name="h3_44"></a></p><h3 id="3-10-为什么要进行系统拆分？拆分不用-Dubbo-可以吗？"><a href="#3-10-为什么要进行系统拆分？拆分不用-Dubbo-可以吗？" class="headerlink" title="3.10. 为什么要进行系统拆分？拆分不用 Dubbo 可以吗？"></a>3.10. 为什么要进行系统拆分？拆分不用 Dubbo 可以吗？</h3><blockquote><p>系统拆分从资源角度分为：应用拆分和数据库拆分。<br>从采用的先后顺序可分为：水平扩展、垂直拆分、业务拆分、水平拆分。</p></blockquote><p> <br /><img src="https://cdn.nlark.com/yuque/0/2020/jpeg/360514/1587442953578-074506fb-a342-4ada-a235-22755ec27c58.jpeg#align=left&display=inline&height=820&margin=%5Bobject%20Object%5D&originHeight=820&originWidth=1310&size=0&status=done&style=none&width=1310" alt=""><br /> </p><blockquote><p>是否使用服务依据实际业务场景来决定。<br>当垂直应用越来越多，应用之间交互不可避免，将核心业务抽取出来，作为独立的服务，逐渐形成稳定的服务中心，使前端应用能更快速的响应多变的市场需求。此时，用于提高业务复用及整合的分布式服务框架(RPC)是关键。<br>当服务越来越多，容量的评估，小服务资源的浪费等问题逐渐显现，此时需增加一个调度中心基于访问压力实时管理集群容量，提高集群利用率。此时，用于提高机器利用率的资源调度和治理中心(SOA)是关键。</p></blockquote> <br /><p><a name="h3_45"></a></p><h3 id="3-11-Dubbo-和-Thrift-有什么区别？"><a href="#3-11-Dubbo-和-Thrift-有什么区别？" class="headerlink" title="3.11. Dubbo 和 Thrift 有什么区别？"></a>3.11. Dubbo 和 Thrift 有什么区别？</h3><blockquote><ul><li>Thrift 是跨语言的 RPC 框架。</li><li>Dubbo 支持服务治理，而 Thrift 不支持。</li></ul></blockquote><hr><p>转载面试</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;分布式缓存，分布式消息队列，分布式服务框架&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;转载于：&lt;a href=&quot;https://my.oschina.net/u/3728792/blog/3042368&quot;&gt;https://my.oschina.net/u/3728792/blog/3042368&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;br /&gt;
    
    </summary>
    
    
      <category term="面试" scheme="http://blog.fansl.com.cn/categories/%E9%9D%A2%E8%AF%95/"/>
    
    
      <category term="Java" scheme="http://blog.fansl.com.cn/tags/Java/"/>
    
      <category term="面试" scheme="http://blog.fansl.com.cn/tags/%E9%9D%A2%E8%AF%95/"/>
    
      <category term="分布式" scheme="http://blog.fansl.com.cn/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://blog.fansl.com.cn/2019/09/19/helloworld/"/>
    <id>http://blog.fansl.com.cn/2019/09/19/helloworld/</id>
    <published>2019-09-19T14:10:43.000Z</published>
    <updated>2020-06-05T12:06:37.833Z</updated>
    
    <content type="html"><![CDATA[<div id="hexo-blog-encrypt" data-wpm="不好意思，密码没对哦，在检查检查呢！" data-whm="不好意思，信息无法验证！">  <div class="hbe-input-container">  <input type="password" id="hbePass" placeholder="" />    <label for="hbePass">嗨，请准确无误地输入密码查看哟！</label>    <div class="bottom-line"></div>  </div>  <script id="hbeData" type="hbeData" data-hmacdigest="36b02f15beb502330acb46751761f9034712d6015a8fd2a620c55289b72b0112">04b96cf03f1b5d00286d72390b6bf2e0817acbfddb7147d2fcc01912c7f5c0f9713c9c317ba53b9347fde83c930f8c77af411014f8ec84eef7465f6027f6e563b20763efbf9fac1db105face649d36b82b8e5a28894e0322accb07eba0f38491487fddc38b18732e21e4d5a09a208486db90f1b471e152ae582639c98996b3d9545b516ad74403d379a378e897878b9754f5f3c9a9c1cbf034ea3b155b6217c7c2a8ce65fc5458e94d70325ea68e520f7a7ed29b19c24e71d2dd5a163ab5e832849afad0abe9784c4fd18fabc279182b8af54ef67d705222ff90b349331f6dd1ec831f38c55784c3eaa91ce5b4a0c9a95b4266599f6a585f00bc84ead7b4ed5b194183eed780bf7bd818d1b408ce1a9de0ba8e623484f02131805386fc2dca0f711b3acda6b8fbaad70f40297fc2d61765dad86de7eaffc25a2889a43a69ef1f5d3dee32f35783a2d780ea5da52762675e3325a5f4dee82541127c686d47ee2db59fb8f0bdd90eb21e8e80147bcc58ffd18c21aad8210a07aa3c89d3a683b406eda3bbb7f23d4ecc20c5e3557e7bdbdb4c398a4eabadacdb463d11127cbacc66973021d5a393ecddf0ab48fbb7cb3af1ebd14e512a18c8efbf5078725aa46959ea4d882da1cb78000b82049e77ad1f0e8e47e534b89d6fad32e797355b63d8792c9a012fba49f5841eeb51dffe4a18be880def829c7c16c7efb2f11c92432dbcf9de755b3574c9cd7b09adcb8beabcfa36e020181ef874b2632803752f1b7b158bfaafba643fec8139a7cae21de737609954146f954d48832d3fdef43f535ad52ffe6fb894a3dd9a3e89ef3ab0b46ec11c6f4bfc3e37cc7ba4ebe06d244906e98518c2fae0546905a5e71fae3b47d55f731a58aa2a7573e8b128f0bb4916136f8d4dac285cdc82b004ab2bfd2fe070e51f3e698e9951d6fcf4cd86c3dc85b2cf7be0086a0193eb79b4aa7902b43368e32091c9ac3176f16e8974f17ed3c48279ab1e906ad9a799fc2e345f6560b1677d71db74dabce987f7d652b6d0a8c1f8a355c1372946957b8392ca9a471addf7d9a13863e840952bb0d0f59200852c2432214c430362e370220bdb95d0c33112b640ee82574e2cac5079d1190ccd43c0e9e630d73c233ccbeb05d4fd12ff9b878355345b3e9fc5d20a13ae82e4f9f2c7379704891124911f5962d2a2d5822406fcb4dc9014c7a73df34b38a07418d129cb0ce0996ce4450aa11ceb7c1cdab744f419a9fac0a7cddcd33531fefeb5b507be19923eccfa136a9c071e149f88069d33f5e1a19e1585d165c108bd383322a02ca8e9306f724dbfc7a68de47e7e456839f31d8c4c66fe56a4e972406a6d4be47c41ee93a43af54fb2f83f6a63066ee05189d5c305fd11616da3a1f9263cc412ce52a13043d124a09690f182bc041f5be34c9bdde5d942d32f9556b4dedff5f4a706932c979358cdfdc12fdadb332fafd94b7a063548b8537da2fca391b4d7b756e5d67d50c7e775655f21a7d9ee2ee72945be50458b000d4bf8c25546e78907f46881dc9c3624da70a59a04b30c8f68fedeb5c429970234b4b8b48b854b779ff3815eda7c31ce31cfa2e32130f3314a1326c223c15e3a828e45a9ae109e39f07fa5dd32c6511931a9c482587c5c673ca33e8af79532d23f14eb0f78655c4f7aab54764c0488e4758efd6f64a64dadffc4c33a4a2321358b23f859830e57d4460e37f8da1c8cd0f7516a268a871473cd0376045ed07f6b5a016bac5f5a6c567bf35d1de4b82ae89d18153e95eb3b07215e13f4f84b6493bb27ccdf627e0d82a8d6d51e5c01217d16c3c94ff9099c37498940138dc45168515cc975004c86ce5fed210a0017e121fab3a21f6daf71f3d5455821d03c7615f7af620c9824ce3c4dc9b50c97fb48f9332b3fbdae0d5a21d0b11e6c024ed452d3e320bb725202d1129855da710174e52e81c0c0f40d63bc1f9f2e0e389fe41cbdf577caf8a0c8d0400606172e50431ce5e71a5a735580001f00f42ae68d3e4f043f3b3bea34d893e4d0278c1612fcd8cc633d28769b776822921b20c7aa2b4eaa14f4b79f8254019b5f29781630fdbad4fe228ce80b352a758c56d60a7f38d28fc1869971ef07145f6832cdb9bf5f96f21357133eccb54a2c3f451afa4d255c797d87f8929b26dc53e42b5e3f5307e602acc878d3bc05a783aae624b64bc39407d08a56ad1d5caa58a7dc489e7a7b35a3243f4beedb1879e0c0d10ebda5a3c4b47660f1de349862d5e3f52060c45cf90535987b8397389cd7d145b992642c4b566375542c7857fa5235d73913bfafdd9bdc14a825b3259d1d6f3cb00990da35abdf9cb056f756e2fedfe2d23f35cc65e24438ed8d7c5ea440e5d034229b2a3395e28de7cc1a24c68454d0d235d36a0b564d99172e95b714335564c7e6c03a0a2f2fa420dfa2ab8c65d5fedee2d06e138a35320dc5f6040dfabafeb06671dc0c0e21634486ff9b4b277eae8208068e21092cde276bb2ec2de3a3d28adb23758996e58bfc7e8aff215f7425202dc8dc0211390e6bc139dee1ce2a68cfb7e150263a58000fbb6eb66bb6809f63cc179e6ed1b8c70262ba950bf5f837aa868e1b72dfdcc561225ea155c76d267f99afe8947ec32ddd683cb068c578c97b323e9036660e0057367e217cabc735d0d72ac7f621b79d0501d02cd8704c92f3a8bef0c5876be9f6b9187a4baeead75161b57bca18e3ad5ff722c7fe245ae907b95a3b5675b9b54b8a1ab307ff1e348ed039b8ba5a2f3dae2d1693d5bc3fdbc4d8bc72793402de10dba195e1d876aa5dbacff40518bf64228184fe2e452488fefbf7c0ebacaec1abdb662f02baf07dfbf6d0dc245c8b9487975337722106351141b055e5771711e1a0d65d96965f9f22d25ae1cf32f58867a49d8fbb065ad3c683a16e38c397b7ec1a3b7053f316c2ac0b4cc60af525469acc19b64e9715cd33ff97407e35c55f470233a2dcd6cd5e866c0b9ab498c10afd3c088b3785e5c33d1d3942d974b2963969d15d5c7526aa634d2cdf8ab75e5d894034e3e2b56b96eec10a693ec56ffa8711cc1853e853057019690eb8f2a8bd9dbc5ef3f43b1958982127215885bcba701972691251737d7344f2901222aaed7a409eb0d6c9bca05c6691c9580dcc92795349cf8d93c2ffdef490c83d5d084ee520d32e02c9d4263842b884434c612cb754b5b1340ad4149720ce392c32fb044047b828fa5e792df64a7d3715a27242e432e1d6b18905ec1a89ce3706e4c8094b041b77fbb29530d96c2b65f8541bb7b2b971864d88d8c044dbba12470d0dd726ce276b951b8056da273c08e125fb04de997306fe79b129d9def2a16e7434f39eef0eb355da2ac0c50651fad8edf7ae63c7d5fd9001e655ba1fdcc4711faceadf6c24e9585eeb3485b28b3da029799bc7cedf790516255c083f53305a54c5c6a134c7b84a124c89c3c8ef9fc513d3e2a21ee6207fbd560b6088865a699b688b539ce3c020bdf03d9b585f697695bd0b94f1a3e2ba531a3dd41353a7a3667d036e5dc243f78831df21a5a69d9ff987a7591cb64ccd52469a8e09a73acbbb63d00a9f55477473f92c18914ad2ed2de933dc558cd3b3621f8df4f9e1332a89f9173e98e8903492a807aff44e2d9d45fa181b95e09b5f9bd00650db7ee982eb76bda4c556302cad1356d8a3fe604946b2c9929d14fb43eec79e4294fcc2afb800f1fb98f86e26b8eca0aca51bee18024afc608a3d7d54d393b01acb4a75837c54cc9141f7662186a9e75e012cafaca26a50e2c6e0f6cf4ed724c215e4f2d58da76f5b7d197125eeab64a9aecf78fa3f197047ccdd69c64cf74d0e3fc58ecef92868a8564a58747d1e3f233f761909530d0337a45b7e64845738ee48a6db82dc686b2637a29de6ee840a9561aca0a6cc808e985fb15fef98644cb863eb484acca27aaf39d364fd963e2ba46f05f367d840ad7dfc3d312f3f69c3b78259c22bcf9b23be9d3b252788f5c66fcb49351f7b2329155020bc7cb53691866de01f6c558a17bc53bb7b0da10a709c8b6cdfbd25c208109896b51556a9eb6c813deaa3018258faf2385e6eea6c0e7805818e0c6b13c3c80819f60f561441cbbd008c2146ebfbb75282eaea6c6091e9241d5a4d2e54df41343857a2bbb4d9a1033c1a3659b6c450ed9267c6856f44d0e0fb7485f24238701987cabc47fddfc9e766c69ed24b23c8fa5de64d095efc77368438be4e13e84b1d7e299a0cae3a60dac6bc4e0fe6fdd456ec881a10a4b1d100efef53424693278b3175dabce0e61c99d90a602e2603bc1ea99b842cf5a3046a1eed0681b356f069d9fc2b1b33befdc088ec8f8f31b47ca1ef36ebfbf0be3f004ad9b00b5d13411fd94928a1a3a13088dd875af8177924aa8ac9e596e07d2eed3982ce3fa0ec357091ab84480bf8d2463d9b836f2294e8191e58c53eb8b0ea46bbd46e45f6e9fd04961b45c53e9a66f5ace153bddd932f36bd036da46f41a55790fff2622fd470f64d93de22a226b3efe84d3b0914610b7efa7910963468d1cf0ec365167dc1797633440fcf050ae04a74ad5cd6d3533f7f932e0b45fae8727657c42be48e25a88d6eb0e5f9a9bf3ac64c5bb1f2a87b0f01789569bcf9f047af0ceac4ec0a642cc1b566f0f51029638c462a1aad737f8801a36b07aa10518ee010054795a702e38c293566c8ab31315752e09dcf3c7d653066c9f63f769dd79b4009b39583ef1f70c487f453deaabcd4ba9dc438b4aa273bcd6e986fea3ef563d57118e6e1aef055965ed78e3bd11d5fc504abfaffaf3b831ca732f16c2b5528043381bdbab6fca5ba2000900b7e497a1d156025211bb17560763a79132a6ebeeadcc81928ba6ed0eddec444ad2357ab3c7ccf0edd15e7d5ef08056bd37a7f9f408ccbac2067abcb219280440849d7bf1a9852522a703139245553e9bac6d9721e98bd0e920b95b125f89cce5c</script></div><script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
    
    <summary type="html">
    
      咦，这是一篇加密文章，好像需要输入密码才能查看呢！
    
    </summary>
    
    
      <category term="测试" scheme="http://blog.fansl.com.cn/categories/%E6%B5%8B%E8%AF%95/"/>
    
    
      <category term="测试" scheme="http://blog.fansl.com.cn/tags/%E6%B5%8B%E8%AF%95/"/>
    
  </entry>
  
</feed>
