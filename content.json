{"pages":[{"title":"","text":"个人简介 试着点击“显示一言” —出自《xxx》 function showHitokoto (event) { // event.target.classList.add('is-loading'); $.ajax({ type: 'GET', url: 'https://v1.hitokoto.cn/', success: function (data) { $('.hitokoto').text(data.hitokoto); $('.hitokotoFrom').text(data.from); // event.target.classList.remove('is-loading'); } }); } showHitokoto(); 个人信息 软件工程专业 从事JAVA后端开发 码畜一枚 热爱生活 做个好人 博客信息 网站由Hexo搭建，采用的Icarus主题 和Amazing主题 追求尽可能的简洁，清晰，易用。 记录工作生活中的点滴事。 时间轴记录","link":"/about/index.html"},{"title":"","text":"唐艺昕 李沁 李一桐 gakki 图片搜集于互联网，侵权请留言，马上处理😊。","link":"/album/index.html"},{"title":"大佬们","text":"申请友链须知 原则上只和技术类博客交换，但不包括含有和色情、暴力、政治敏感的网站。 不和剽窃、侵权、无诚信的网站交换，优先和具有原创作品的网站交换。 申请请提供：站点名称、站点链接、站点描述、logo或头像（不要设置防盗链）。 排名不分先后，刷新后重排，更新信息后请留言告知。 会定期清理很久很久不更新的、不符合要求的友链，不再另行通知。 本站不存储友链图片，如果友链图片换了无法更新。图片裂了的会替换成默认图，需要更换的请留言告知。 本站友链信息如下，申请友链前请先添加本站信息： url：网址地址 avatar：头像图片链接 name：昵称 blog：网址名称 desc：一句话描述，描述一下 自己 或者 站点 或者 喜欢的话(太长会展示不全) color：样式颜色,默认灰色() 点击展开代码 >folded12345678{ \"url\": \"https://fanshenglong.github.io\", \"avatar\": \"https://fanshenglong.github.io/images/avatar.jpg\", \"name\": \"fanshenglong\", \"blog\": \"fansl\", \"desc\": \"热爱生活，热爱开源。\", \"color\": \"#66CCFF\"}","link":"/friend/index.html"},{"title":"","text":"&nbsp;&nbsp;听听音乐 音乐播放器由mePlayer提供，布局参照网友博客所作，感谢作者的辛勤付出。更多音乐分享请查看歌单。 &nbsp;&nbsp;看看视频 ->点击以下条目开始播放视频,向下滑动查看更多","link":"/media/index.html"},{"title":"","text":"来而不往非礼也畅所欲言，有留必应","link":"/message/index.html"},{"title":"音乐歌单收藏","text":"--- 温馨提示：选择喜欢的音乐双击播放，由于版权原因部分不能播放。如果喜欢歌单收藏一下，去网易云都能播放哟！","link":"/music/index.html"},{"title":"","text":"碎碎念 tips：github登录后按时间正序查看、可点赞加❤️、本插件地址..「+99次查看」 碎碎念加载中，请稍等... $.getScript(\"/js/gitalk_self.min.js\", function () { var gitalk = new Gitalk({ clientID: '547655d4ccec493dad48', clientSecret: '92207d66ca2ea4fb5b99d571c84da708f894f88a', id: '666666', repo: 'issue_database', owner: 'fansl', admin: \"fansl\", createIssueManually: true, distractionFreeMode: false }); gitalk.render('comment-container1'); });","link":"/self-talking/index.html"}],"posts":[{"title":"Hello World","text":"4630436162ade97ba2718b7d0c4b3b630ef8b034c35893a7afa4c54a5752d90eba191a593f89497fdfca691efaf72d5caa0c664d8e7a85bd833fac72ade59ddbf66b4bdec75a2ed1e83f57bcb279b78cfc65fbc18f7606dbec4f8a0cfd661414c92c100d2773e693a5c8b2ccac7fa14accc64f83b5b264a4d5fdf6bd69eaa8f482afd099013e76ff4e51aba738e821baa622005a4c66f56ab33cf2343fe1cf2e0172f93bd31fce364b9080e27185a46d57dfee48fa7acad956c60072fcdef615172cb1bc7e001573317575587dc894bce886edcd55082bdd6cd35662d9dc16b455d8de94f0f748281ebc2f8fa61b6e163bb39f97ace0f687580a08ac82e3d87b3cc4a860bcf9f4cac4016a5fa2510665cf62bfb02d13da9ca02935718c0bd99b11b5e79bd4e7a647ecd3cf5057d0276a3257aaa2afafd46bcc7c95e6507f174e3f93f32eaa4c3bebf881f993f9dba5422b618db6225f353dc0f7252449add8c0c7fd080f451f51cada2f5a895e1917fc71906f1e6fd9e214fd2a84fa2bcd8b913f3f61e4d73c435fb61097e7e4c2b294bf8ba59e670d6c9c7b83b124e83f44dbca62a5fddfd3b5e44cbc52efee450628dc8be8eb029e8f3c65a168d4f9429aa41f0491aa5668529569effabf1a31a2343c0d8ef50d308241d668ac0e677cd017e153ea10344473ccad83b9f6c7afdc6fc95d5b385fc5c8b27f004b85c6128b64042a12774f407fa9641df7d8398806622a4bd9cb6d0cae2160ff092f48e328e8035940f3fb3cb803363a2de0dabc087523881b07a1c951d9b6fe6ccb1023c529f2c727905961317b87a512604ffa70b2cdca76062d98eb06551b2885fa3995019b942542a5fb2eb7adb0aaa3d96c2fa3a6f89960363a447e91da3dcc802735fb2532358e8e29a9775ad3f5deef28277ee2a0a46e07c45fd7419d5a4431deed700ee20443c3fe29ff0ec5aabba4e0a0954394c08f4bb8a0fd5858339313c00485a4194ce567324238f8d8efd40a332509b88236d7b97a700dbb30f70303f5a172e5c7234485d2682084751d9220e709d8d83cb9bfda50b7d165ed95e4c7a91f4ed43a2f39e8f6c913e88bfb886f17f2bebdef51f7a3b62e1485b3c766a996eff2c65451ce501e55479181fe58dbfc7dbf9232ba57911e51f742d57e81ae204b6089e20715a8ae793fd825c901d95f5b8f55de16c1f15b17a099a0a444c7e7edf8af97629ae46f0811cd512708de161cc8e0192d87197f99e0555c389c7105ee634ec8aaf8c687310691823d8ee7baf97d6cf2bbf22cc6500710591449ed122e0086187312c6e9230588257a658b2821b6d683859747ed6bfd39bc8745b9e328158d32d6f1f8edc494ca3e2abe0f661c3267d6e168102bece28cb5ff778ff61731a5f550004b19040ab4ad3bf3f5f0ec74cb6dbbc8aa47fff6638dea922bb8bde815e9e6f9385acfa31633fdcf63bb160f5a9788528c5aef2cdccaa3489e21f9845ce550ab64a52c2737245a356af2ae77bc609e7354846fa8ea2605d802406741c2cc7bac8dcca0be4575368eec8d391d38200f4d8d0361bd5eafd52e4f0fd71910927fb707724fa7b61aaf22a7b5aeb1eb46ae63fdc6f7322a0552a1122da3f7963bcb39b773c9c995fd4a68b80be55c3356d370f65f5185ba562cbcf8923e2b1ba6f79c1929feda8e3ce19a67a4a3d999cced094c4995ad09eca73e676f73abae125cb2b3b30cf63032912b38bfa16c03ff3b638392e1b04a1ddadf495e5be0769205340845c47e417e177b00b75e187ba423a5523a3a9257e919b1f2cc0666fe88ff359b20fd4f56d964115f4a690e6bdc874f48421b5c8696d385e24b93d33c05c4aa55e2b20e660d59b9f282b4f65ff8170197bae4185d8838974b23e179a1bfa85a88f395a1e907aa15fa49c8a825766a1b1d07702f5cfd3d4c124a1c18aef8347ab3c04ac78b5354a9c54336f5152132f0d806b3b425e938863f24dd84247976f062a7826295ad0e6f6ccb4e49c7000fdbbd8c66d9611ead5bc9985c990311460614522bb4c796d774548ea84778f32aa3fb4eead5f4ad0d2579cd9021375a45c51b05741bd437189d2b5fd20e45152ef23aae7680db44f2c542528defedacbda826d6edab616f5e71cf753e3e970c138b02dddfd27cac939603d7f358013863fc02a8ecb84e6beb12134faa45da8c713a4ebd75ea9c2ef537850bf8e19d333f0cdc74cadd830ee27d7777af9bc9759d26dbe8856614fb169796b61419072e8ac8f9455d6991e6e95341264a3a3b12e63d9fabe3c3083bda00b334a11b4c90b2524c62e87c8f095aa9f9dc5d29b3f45e586a1a7e1a15857fb1edec32932e20077885d691ca18e813fcf83824db9629885be93d4f686cde55ed5c77775bd88291f6e04690a8342878f80ebe3e5452dcde67ad3a5ac1e225a48bba5b0a3f788ca3b361f17cb8d9d3e74ecfb7a5d2201da105e7e9a4fc31fd6d440bc625602e8f14e151e0bbfa0680022c5c07ad4a67391bf06b854f0c530b01c6480e9a2611879efc094db2aa7b4414f672987af4091a48a6938dd6766c4fbfe68d10936c16dc69dd12642b11b6619abfdfbfacf3de5ea109f696f8afc9dc6cee23397fbca4883a8c3b51e682964071369d947f8ce8c1780022b0ce31690fe1d09e2a7327bc1b4f0a37846426ec21af885d97b3f8463eee143e9ed666eebbbe27d69e83d4ee2ac0612993a6e4ebd2a46079cfffe06b148906eddade5ec69419537b88547e198e1fa993d0db7f21ff21a01d8e02e603513495aca3f46d7a34fd608a426dddc0d4c97efb7c2a6d644384f574fd511dc22ad25ea0b6c65e78a02acf46fd7847f0cfe0f63a8894b7e604a60f3b39af943457319fb9d331a3d9e9dd045723d21248e0e27fb361d9942a7b62f56d4f62300114e97092648d0a8cd8d8425fbabcff4c2800cb11381b76f410e78f1a463b0c8ed2d471ef20f639ddb6251dfee3d943aaec862e83c50a6080753cda0d42d90ce58be2be0db9ba1ddab76de13114b95f5d58b98bd09c455cc978b8f14f8e386c0820f21c1de2038500d699d9bb8de9373b3e06e3bb4abf46f8999375eea561567dcfe6b67c8006414690b86fb2a3b8267ba9ee0072b810b753c0b31477ac0456a6bc758413511634e0565abc67e043798e3014053833b89802edfb43e1f40e152f253ce59a179c66842ca02c01b2bbf366dae641c38aee3ffc223e44ddee8e7d6916966dcaff83cb2e065d748111b44d17da4b8724b2b93968c0404b367a2195755b79143632be5beb85070b114bc15211767f088a23685d58f48ff4f51c132ab9398c372acf0960ca25bf01f225fd8041f3f6cec7ce5d20a5a15821c36c03c03e2597a9fea6b4cf8f9131f5efb1bf315242809b3e1930a150e22ffba1d353dfc14b855ab5faf75f36df64f0c410be5796287ba3542665fbd3c9419099902438878028528fff7e742c8cbbd9b313e25f45695b08c7c8eac4f01d74153fc2e5a50587d1cda89c268ca644b264968548e0801aaaf49c42e74b316fe8977226555ffa510df115c497e13b8de5690e10d2f96f6c074ec87574e0b21e442f4eb024c2b5c02002dd09dcb87460effc5878f627e9f3751ca86a063bbc5c5ce92e28bc765e34203522f4089692a51f651a71acfb4ddcd0ab33c13ba4ef02e458a97ed013d993e49de316d3978c39611e155d3df35fbb356d20c991255e2292e7b2a978a84e45546c77f309d7285b16390f066ce34cc06ead2ffb5647f33834797ace71bb2e6248a2fb37dd2bf5e2a8f51e25551686006d1f862dfc3fa4550e15530f7f2cc6cb1431caf510d3302837b46b8bfa79044e2a9b81fd38879952f0b326742d0faab368467fcb860a5c7439d8c0a5236c2fc2a5fede7cfc8274f94e7959ba25991cb7634a66ab145ad976ad50f8f40ec4f1a23ad3d052b98576e36cd80e8fe33c7949b3f0bd34a840d13e26a4798d2cd636e33c1383eac9e34af4462384dfa105f130fb13fffcebeaae73c7e720da7888b0be36928f08e168e1afa5754bc1c670babb97a1be169809ef9fe9481311b150957e6066fb16718dd102fc99a3a92a60fa17c83273dc0c39ae046041829782f37573eb50c2c500a26daa80ed07cc1264ead8e71521de881fff581202912f75c3f6013d06bbdfcff2d4d7ea9a454ff75d0c50db4c5c795c1d41711fec50c200079b09ae710878156c549e2b77d14a997adc6c0eaf7e9c5d3074c92f21c707f7c15ce3aea62a41c2f10579544116f88f96ba2e0048d0fb7a1322d9b77c84fc3e096806595399d46324b3dfe9c013fbfdbc750f5509b5754aefae9ce91433b73d8a897b114a9492d1565f9ca1802eeb802231bbea4d4eaee1e691dd544e73d5565636beb9c05336dfeee357cc42520044e5b9c1f6a1a261095b44aedc95dbd75b20541f425771c8036e383d84099df4e07a4159bad539fc59f91120858ef994fe9725371c4db721e6ed750d06203167fb9fa880a79c555d22dcab99e8462f71d4e5fe3abd643c6d46de33917bdb91a4d4197a006708e7f305939f181fb8847f3d479a094b929dda4b3db7d6b7b31be7703e2b475df7632b2a9af0e3ab543a1a20f9f0dcb04dfdcb2fb667da31fea5445d462946831c1c02c6709bf78a9f0d4f4fe48217d2da8a6d14c7394bd8abf23325400f22b4c24b9f334e5942be7685ebd9a01f5bb04b577a22ff3cadab5be0bb77544aeaa8a4a50e8adfcd63deace3c845367018365680c44994c1e69cface1815a4f24073ecce4eda7bed855d4781615817af6962390b594997992174c4c952107a7b676e3cb8d382e4317c0a43ca63c3b425a91b83ecb7261f530eb98354d3ff26cca60cde94dda2aec5c914f8bd8e41e5f83d207a8e314b02b2ed7469089582e572901cbfab23cb3e0eff8aff850f0e3e2515bbe70dfa89e694d3526b72f1d268594f871f7801b32e51a0a909a862de9ab47ee4c2324b8f12130baedcdc5c0221 嗨，请准确无误地输入密码查看哟！","link":"/2019/09/19/helloworld/"},{"title":"hexo创建一篇新文章或者新的页面","text":"你可以执行hexo new [layout] &lt;title&gt;命令来创建一篇新文章或者新的页面 您可以在命令中指定文章的布局（layout），默认为 post，可以通过修改 _config.yml 中的 default_layout 参数来指定默认布局。 布局(layout)Hexo 有三种默认布局：post、page 和 draft。在创建者三种不同类型的文件时，它们将会被保存到不同的路径；而您自定义的其他布局和 post 相同，都将储存到 source/_posts 文件夹。 布局 路径 post source/_posts page source draft source/_drafts 其他参数 参数 描述 -p, –path 自定义新文章的路径 -r, –replace 如果存在同名文章，将其替换 -s, –slug 文章的 Slug，作为新文章的文件名和发布后的 URL 默认情况下，Hexo 会使用文章的标题来决定文章文件的路径。对于独立页面来说，Hexo 会创建一个以标题为名字的目录，并在目录中放置一个 index.md 文件。你可以使用 --path 参数来覆盖上述行为、自行决定文件的目录： hexo new page –path about/me “About me” 以上命令会创建一个 source/about/me.md 文件，同时 Front Matter 中的 title 为 &quot;About me&quot;注意！title 是必须指定的！如果你这么做并不能达到你的目的： hexo new page –path about/me 此时 Hexo 会创建 source/_posts/about/me.md，同时 me.md 的 Front Matter 中的 title 为 &quot;page&quot;。这是因为在上述命令中，hexo-cli 将 page 视为指定文章的标题、并采用默认的 layout。 参考文章: hexo-基本操作-写作 hexo-开始使用-命令","link":"/2020/05/13/hexo/"},{"title":"享元模式","text":"享元模式是设计模式中少数几个以提高系统性能为目的的模式之一。它的核心思想是：如果在一个系统中存在多个相同的对象，那么只需共享一份对象的拷贝，而不必为每一次使用都创建新的对象。在享元模式中，由于需要构造和维护这些可以共享的对象，因此，常常出现一个工厂类，用于维护和创建对象。享元模式对性能的提升的主要帮助有两点： 可以节省重复创建对象的开销，因为被享元模式维护的相同对象只会被创建一次，当创建对象比较耗时时，便可以节省大量时间。 由于创建对象的数量减少，所以对系统内存的需求也减少，这将是的GC的压力也响应地降低，进而使得系统拥有一个更健康的内存结构和更快的反应速度。 享元模式的主要角色有享元工厂、抽象享元、具体享元和主函数几部分组成。 享元模式角色 角色 作用 享元工厂 用于创建具体享元类，维护相同的享元对象。它保证相同的享元对象可以被系统共享。即，其内部使用了类似单例模式的算法，当请求对象已经存在时，直接返回对象，不存在时再创建对象。 抽象享元 定义需共享的对象的业务接口。享元类被创建出来总是为了实现某些特定的业务逻辑，而抽象享元便定义这些逻辑的语义行为。 具体享元类 实现抽象享元类的接口，完成一些具体的逻辑 Main 使用享元模式的组件，通过享元工厂获取享元对象 享元模式的结构如图享元工厂是享元模式的核心，它需要确保系统可以共享相同的对象。一般情况下，享元工厂会维护一个对象列表，当任何组件尝试获取享元类时，如果请求的享元类已经被创建，则直接返回已有的享元类；若没有，则创建一个新的享元对象，并将它加入到维护队列中。 注意：享元模式是为数不多的，只为提升系统性能而生的设计模式。它的主要作用就是复用大对象（重量级对象），以节省内存空间和对象创建时间。 享元模式的一个典型应用是在SAAS系统中。SAAS即Software As A Service,是目前比较流行的一种软件应用模式。以一个人事管理系统的SAAS软件为例，假设公司甲、乙、丙均为这个SAAS系统的用户，则定义每个公司为这套系统的一个租户。每个公司（租户）又各有100个员工。如果这些公司的所有员工都可以登陆这套系统查看自己的收入情况，并且为了系统安全，每个公司都拥有自己独立的数据库。为了使系统的设计最为合理，在这种情况下，便可以使用享元模式为每个租户分别提供工资查询接口，而每个公司下的所有员工可以共享一个查询（因为一个租户下所有的员工数据都存在一个数据库中，他们共享数据库链接）。这样，系统只需要3个共享实例，就足以应付300个员工查询请求了。ReportManagerFactory为享元工厂，负责创建具体的报表工具，它确保每个公司下的所有员工都共享一个具体的享元实例（FinancialReportManager或者EmployeeReportManager）。这样，当公司甲的两个员工登录，进行财务查询时，系统不必为两个员工都创建FinancialReportManager,而可以让他们共享一个FinancialReportManager实例。通过这个实例，还可以进一步了解享元工厂和对象池的一个重要区别。在一个对象池中，所有的对象都是等价的，任意两个对象在任何使用场景中都可以被对象池中的其他对象代替。而在享元模式中，享元工厂所维护的所有对象都是不同的，任何两个对象间不能相互代替。如本例中，为公司甲创建的FinancialReportManagerA和为公司乙创建的FinancialReportManagerB分别对应了后台各自不同的数据库，因此，两者是不可互相替代的。 注意：享元模式和对象池的最大不同在于：享元对象是不可相互替代的，它们各自都有各自的含义和用途；而对象池的对象都是等价的，如数据库连接池中的数据库链接。 本例中的享元对象接口的实现如下，它用于创建一个报表。即，所有的报表生成类将作为享元对象在一个公司中共享。 123public interface IReportManager{ String createReport();} 以下是两个报表生成的实例，分别对应员工财务收入报表和员工个人信息报表。他们都是具体的享元类。 1234567891011121314151617181920public class FinancialReportManager implements IReportManager{//财务报表 protected String tenantId = null;//租户ID public FinancialReportManager(String tenantId){ this.tenantId = tenantId; } @Override public String createReport(){ return \" this is a financial report\"; } }public class EmployeeReportManager implements IReportManager{//员工报表 protected String tenantId = null;//租户ID public FinancialReportManager(String tenantId){ this.tenantId = tenantId; } @Override public String createReport(){ return \" this is an employee report\"; } } 最为核心的享元工厂类实现如下，它也是享元模式的精髓所在。它确保同一个公司（租户）使用相同的对象产生报表。这是相当有意义的，否则系统可能会为每个员工生成各自的报表对象，导致系统开销激增。 1234567891011121314151617181920public class ReportManagerFactory{ Map&lt;String,IReportManager&gt; financialReportManager= new HashMap&lt;String,IReportManager&gt;(); Map&lt;String,IReportManager&gt; employeeReportManager= new HashMap&lt;String,IReportManager&gt;(); IReportManager getFinancialManager(String tenantId){ IReportManager r = financialReportManager.get(tenantId); if(r==null){ r = new FinancialReportManager(tenantId); financialReportManager.put(tenantId,r); } return r; } IReportManager getEmployeeManager(String tenantId){ IReportManager r = employeeReportManager.get(tenantId); if(r==null){ r = new EmployeeReportManager(tenantId); employeeReportManager.put(tenantId,r); } return r; }} 享元模式使用方法如下： 12345public static void main(String[] args) { ReportMangerFactory rmf = new ReportMangerFactory(); IReportManager rm = rmf.getFinancialReportManger(\"A\"); System.out.println(rm.createReport());} ReportMangerFactory作为享元工厂，以租客的ID为索引，维护了一个享元对象的集合，它确保相同租客的请求都返回同一个享元实例，确保享元对象的有效复用。 参考文章: Java程序性能优化","link":"/2020/06/05/flyweight/"},{"title":"代理模式","text":"代理模式也是一种很常见的设计模式。它使用代理对象完成用户请求，屏蔽用户对真实对象的访问。就如同现实中的代理一样，代理人被授权执行当事人的一些事宜，而无需当事人出面，从第三方的角度看，似乎当事人并不存在，因为他只和代理人通信。而事实上，代理人是要有当事人的授权，并且在核心问题上还需要请示当事人。在现实中，使用代理的情况很普遍，而且原因也很多。比如，当事人因为某些隐私不方便出面，或者当事人不具备某些相关的专业技能，而需要一个职业人员来完成一些专业的操作，也可能由于当事人没有时间处理事务，而聘用代理人出面。在软件设计中，使用代理模式的意图也很多，比如因为安全原因，需要屏蔽客户端直接访问真实对象；或者在远程调用中，需要使用代理类处理远程方法调用的技术细节；也可能是为了提升系统性能，对真实对象进行封装，从而达到延迟加载的目的。 代理模式的结构代理模式的主要参与者有4个。代理模式角色 角色 作用 主题接口 定义代理类和真实主题的公共对外方法，也是代理类代理真实主题的方法 真实主题 真正实现业务逻辑的类 代理类 用来代理和封装真实主题 Main 客户端，使用代理类和主题接口完成一些工作 以一个简单的示例来阐述使用代理模式实现延迟加载的方法及其意义。假设某客户端软件，有根据用户请求，去数据库查询数据的功能。在查询数据前，需要获得数据库连接，软件开启时，初始化系统的所有类，此时尝试获取数据库连接。当系统有大量的类似操作存在时（比如xml解析等），所有这些初始化操作的叠加，会使得系统的启动速度变得非常缓慢。为此，使用代理模式、代理类，封装对数据库查询中的初始化操作，当系统启动时，初始化这个代理类，而非真实的数据库查询类，而代理类什么都没有做，因此，它的构造是相当迅速的。在系统启动时，将消耗资源最多的方法都使用代理模式分离，就可以加快系统的启动速度，减少用户的等待时间。而在用户真正做查询操作时，再由代理类，单独去加载真实的数据库查询类，完成用户的请求。这个过程就是使用代理模式实现了延迟加载。 注意：代理模式可以用于多种场合，如用于远程调用的网络代理，考虑安全因素的安全代理等。延迟加载只是代理模式的一种应用场景。 延迟加载的核心思想是：如果当前并没有使用这个组件，则不需要真正地初始化它，使用一个代理对象替代它的原有的位置，只要在真正需要使用的时候，才对它进行加载。使用代理模式的延迟加载时非常有意义的，首先，它可以在时间轴上分散系统压力，尤其在系统启动时，不必完成所有的初始化工作，从而加速启动时间；其次，对很多真实主题而言，在软件启动直到被关闭的整个过程中，可能根本不会被调用，初始化这些数据无疑是一种资源浪费。系统显示了使用代理类封装数据库查询类后，系统的启动过程。上图显示了使用代理类封装数据库查询类后，系统的启动过程。若系统不使用代理模式，则在启动时就要初始化DBQuery对象，而使用代理模式后，启动时只需要初始化一个轻量级的对象DBQueryProxy.系统的接口如下图IDBQuery是主题接口，定义代理类和真实类需要对外提供的服务，在本例中定义了实现数据库查询的公共方法request()函数。DBQuery是真实主题，负责实际的业务操作，DBQueryProxy是DBQuery的代理类。 代理模式的实现和使用基于以上设计，IDBQuery的实现如下，它只有一个request()方法 123public interface IDBQuery{ String request();} DBQuery实现如下，它是一个重量级对象，构造会比较慢： 12345678910111213public class DBQuery implements IDBQuery{ public DBQuery(){ try{ Thread.sleep(1000);//模拟链接数据库等耗时操作 }catch(InterruptedException e){ e.printStackTrace(); } } @Override public String request(){ return \"request string\"; }} 代理类DBQueryProxy是轻量级对象，创建很快，用于替代DBQuery的位置： 123456789101112public class DBQueryProxy implements IDBQuery{ private DBQuery real = null; @Override public String request(){ //真正需要的时候，才创建真实对象,创建过程可能很慢 if(null == real){ real = new DBQuery(); } //在多线程环境下，这里返回一个虚假类，类似于Future模式 return real.request(); } } 最后，主函数如下，它引用IDBQuery接口，比使用代理类工作： 123456public class Main{ public static void main(String args[]){ IDBQuery q = new DBQueryProxy();//使用代理 q.request();//在真正使用时才创建真实对象 }} 注意：将代理模式用于实现延迟加载，可以有效地提升系统的启动速度，对改善用户体验有很大的帮助。 动态代理介绍动态代理是指在运行时，动态生成代理类。即，代理类的字节码将在运行时生成并载入当前的ClassLoader.与静态代理类相比，动态类有诸多好处。 不需要为真实主题方法写一个形式上完全一样的封装类，假如主题接口中的方法很多，为每一个接口写一个代理方法也是非常烦人的事，如果接口有变动，则真实主题和代理类都要修改，不利于系统维护； 使用一些动态代理的生成方法甚至可以在运行时指定代理类的执行逻辑，从而大大提升系统灵活性。 注意：动态代理使用字节码动态生成加载技术，在运行时生成并加载类。 生成动态代理类的方法很多，如，JDK自带的动态代理、CGLIB、Javassist或者ASM库。JDK的动态代理使用简单，它内置于JDK中，因此不需要引入第三方Jar包，但相对功能较弱。CGLIB和Javassist都是高级的字节码生成库，总体性能比JDK自带的动态代理好，而且功能十分强大。ASM是低级的字节码生成工具，使用ASM以及近乎于在使用Java bytecode编程，对开发人员要求最高，当然，也是性能最好的一种动态代理生成工具。但ASM的使用过于繁琐，而且性能也没有数量级的提升，于CGLIB等高级字节码生成工具相比，ASM程序的可维护性也较差，如果不是对性能有苛刻要求的场合，还是推荐使用CGLIB或者Javassist. 动态代理实现以上例中的DBQueryProxy为例，使用动态代理生成动态类，替代上例中的DBQueryProxy。首先，使用JDK的动态代理生成代理对象。JDK的动态代理需要实现一个处理方法调用Handler,用于实现代理方法的内部逻辑。 123456789public class JdkDbQueryHandler implements InvocationHandler{ IDBQuery real = null; public Object invoke(Object proxy,Method method,Object[] args) throws Throwable{ if (null == real){ real = new DBQuery();//如果第一次调用，生成真实的对象 } return real.request();//使用真实主题完成实际操作 }} 以上代码实现了一个Handler,可以看到，它的内部逻辑和DBQueryProxy是类似的。在调用真实主题的方法前，先尝试生成真实主题对象。接着，需要使用这个Handler生成动态代理对象： 1234567public static IDBQuery createJdkProxy(){ IDBQuery jdkProxy = (IDBQuery) Proxy.newProxyInstance( ClassLoader.getSystemClassLoader(), new Class[]{IDBQuery.class}, new JdkDbQueryHandler()); return jdkProxy; } 以上代码生成一个实现了IDBQuery接口的代理类，代理类的内部逻辑有jdkDbQueryHandler决定。生成代理类后，有newProxyInstance()方法返回该代理类的一个实例。至此，一个完整的JD动态代理就完成了。CGLIB和Javassist的动态代理的使用和JDK的动态代理非常类似。下面，尝试用CGLIB生成动态代理。CGLIB也需要实现一个处理代理逻辑的切入类： 12345678910public class CglibDbQueryInterceptor implements MethodInterceptor{ IDBQuery real = null; @Override public Object intercept(Object arg0,Method arg1,Object[] arg2,MethodProxy arg3 )throws Throwable{ if (real == null){ real = new DBQuery(); } return real.request(); }} 在这个切入对象的基础上，可以生成动态代理： 12345678public static IDBQuery createCglibProxy(){ Enhancer enhancer = new Enhancer(); enhancer.setCallback(new CglibDbQueryInterceptor());//指定切入器，定义代理类逻辑 enhancer.setInterfaces(new Class[]{IDBQuery.class});//指定实现的接口 IDBQuery cglibProxy = (IDBQuery)enhancer.create();//生成代理类的实例 return cglibProxy; } 使用Javassist生成动态代理可以使用两种方式：一种是使用代理工厂创建，另一种通过使用动态代理创建。使用代理工厂创建时，方法与CGLIB类似，也需要实现一个用于代理逻辑处理的Handler: 123456789public class JavassistDynDbQueryHandler implements MethodHandler{ IDBQuery real = null; public Object invoke(Object arg0,Method arg1,Method arg2,Object[] arg3) throws Throwable{ if(null == real){ real = new DBQuery(); } return real.request(); } } 以这个Handler为基础，创建动态Javassist代理： 123456789public static IDBQuery createJavassitDynProxy throws Exception{ ProxyFactory proxyFactory = new ProxyFactory(); proxyFactory.setInterfaces(new Class[]{DBQuery.class});//指定接口 Class proxyClass = proxyFactory.createClass(); IDBQuery javassistProxy = (IDBQuery)proxyClass.newInstance();//设置handler处理器 ((ProxyObejct)javassistProxy).setHandler(new JavassistDynDbQueryHandler()); return javassistProxy;} Javassist使用动态Java代码创建代理的过程和前文的方法略有不同。Javassist内部可以通过动态Java代码，生成字节码。这种方式创建的动态代理可以非常灵活，甚至可以在运行时生成业务逻辑。 1234567891011121314151617181920public static IDBQuery createJavassistBytecodeDynamicProxy() throws Exception { ClassPool mPool = new ClassPool(true); //定义类名 CtClass mCtc = mPool.makeClass(IDBQuery.class.getName()+\"JavassistBytecodeProxy\"); //需要实现的接口 mCtc.addInterface(mPool.get(IDBQuery.class.getName())); //添加构造函数 mCtc.addConstructor(CtNewConstructor.defaultConstructor(mCtc)); //添加类的字段信息，使用动态java代码 mCtc.addField(CtField.make(\"public \" + IDBQuery.class.getName() + \" real;\",mCtc)); String dbqueryname = DBQuery.class.getName(); //添加方法，这里使用动态Java代码指定内部逻辑 mCtc.addMethod(CtNewMethod.make(\"public String request() {if (real == null){\" + \"real = new \"+dbqueryname+\"();} return real.request();}\",mCtc)); //基于以上信息，生成动态类 Class pc = mCtc.toClass(); //生成动态类的实例 IDBQuery bytecodeProxy = (IDBQuery) pc.newInstance(); return bytecodeProxy; } 在以上代码中，使用CtField.make()方法和CtNewMethod.make()方法在运行时生成了代理类的字段和方法。这些逻辑有Javassist的CtClass对象处理，将Java代码转换为对应的字节码，并生成动态代理类的实例。 注意：与静态代理相比，动态代理可以很大幅度地减少代码行数，并提升系统的灵活性。 在Java中，动态代理类的生成主要涉及对ClassLoader的使用。这里以CGLIB为例，简要阐述动态类的加载过程。使用CGLIB生成动态代理，首先需要生成Enhancer类实例，并指定用于处理代理业务的回调类。在Enhancer.create()方法中，会使用DefaultGeneratorStrategy.Generate()方法生成动态代理类的字节码，并保存在byte数组中。接着使用ReflectUtils.defineClass()方法，通过反射，调用ClassLoader.defineClass()方法，将字节码封装到ClassLoader中，完成类的加载。最后使用RelfectUtils.newInstance()方法，通过发射，生成动态类的实例，并返回该实例。无论使用何种方法生成动态代理，虽然实现细节不同，但主要逻辑都相似： 根据指定的回调类生成Class字节码-&gt;通过defineClass()将字节码定义为类-&gt;使用反射机制生成该类的实例 注意：就动态代理的方法调用性能而言，CGLIB和Javassist的基本动态代码的代理都优于JDK自带的动态代理。此外，JDK的动态代理要就代理类和真实主题都实现同一个接口，而CGLIB和Javassist没有强制要求。 参考文章: Java程序性能优化","link":"/2020/05/15/proxy/"},{"title":"单例模式","text":"单例模式是设计模式中使用最为普遍的模式之一。是一种对象创建模式，用于生产一个对象的具体实例，它可以确保系统中一个类只产生场一个实例。在Java语言中，这样的行为能带来的两大好处：（1）减少频繁使用的对象的创建时间，节省系统开销。（2）new操作减少-&gt;系统内存使用频率降低，减轻GC压力，缩短GC停顿时间。因此对于系统的关键组件和频繁使用的对象，使用单例模式便可以有效的改善系统的性能。 单例的参与者只有单例类和使用者两个角色。单例模式角色 角色 作用 单例类 提供单例的工厂，返回单例 使用者 获取并使用单例类 单例模式的核心在于通过一个接口返回唯一的对象实例。例如下面的单例实现： 点击展开代码 >folded123456789public class Singleton{ private Singleton(){ System.out.println(\"Singleton is create\"); // 创建单例的过程可能会比较慢 } private static Singleton instance = new Singleton(); public static Singleton getInstance(){ return instance; }} 注意,首先单例类必须要有一个private访问级别的构造函数，确保单例不会在系统中的其他代码内被实例化；其次，instance成员变量和getInstance()方法必须是static的。 这种单例的实现方式非常简单，而且十分可靠。它的唯一的不足是无法对instance实例做延迟加载。假如单例的创建过程很慢，而由于instance成员变量是static定义的，因此在JVM加载单例类时，单例对象就会被创建，如果此时，这个单例类在系统中扮演其他角色，那么在任何使用这个单例类的地方都会初始化这个单例变量，而不管是否会被用到。比如单例类作为String工厂，用于创建一些字符串（该类即用于创建单例Singleton，有用于创建String对象）： 点击展开代码 >folded12345678910111213public class Singleton{ private Singleton(){ System.out.println(\"Singleton is create\"); // 创建单例的过程可能会比较慢 } private static Singleton instance = new Singleton(); public static Singleton getInstance(){ return instance; } public static void createString(){ // 这是模拟单例类扮演其他角色 System.out.println(\"createString in Singleton\"); }} 当使用Singleton.createString()执行任务时，程序输出： 12Singleton is create createString in Singleton 可以看到，虽然此时并没有使用单例类，但它还是被创建出来了，这也许是开发人员不想看到的。为了解决这个问题，并以此提高系统在相关函数调用时的反应速度，就需要引入延迟加载机制。 点击展开代码 >folded123456789101112public class LazySingleton{ private LazySingleton(){ System.out.println(\"LazySingleton is create\"); //创建单例的过程可能会比较慢 } private static LazySingleton instance = null; public static synchronized LazySingleton getInstance(){ if(instance == null){ instance = new LazySingleton(); } return instance; }} 首先，对于静态成员变量instance初始值赋予null，确保系统启动时没有额外的负载；其次，在getInstance()工厂方法中，判断当前单例是否已经存在，若存在则返回，不存在则建立单例。这里尤其还要注意，getInstance()方法必须是同步的，否则在多线程环境下，当线程1在新建单例时，完成赋值操作前，线程2可能判断instance为null，故线程2将启动新建单例的程序，而导致多个实例被创建，故同步关键字是必须的。 使用上例中的单例实现，虽然实现了延迟加载功能，但和第一种方法相比，它引入了同步关键字，因此在多线程环境中，它的时耗要远远大于第一种单例模式。 以下测试代码就说明了这个问题： 点击展开代码 >folded12345678@Overridepublic void run(){ for(int i=0;i&lt;100000;i++){ Singleton.getInstance(); // LazySingleton.getInstance(); System.out.println(\"spend:\"+(System.currentTimeMillis()-beginTime)); }} 开启5个线程同时完成以上代码的运行，使用第一种类型的单例耗时1ms,而LazySingleton却相对耗时约300ms。性能至少相差2个数量级。 注意，测试数据绝对值不必太过关注，只关注相对耗时即可。 为了使用延迟加载引入的同步关键字反而降低了系统性能，这不是我们希望看到的，为了解决这个问题，对其进行改进： 点击展开代码 >folded1234567891011public class StaticSingleton{ private StaticSingleton(){ System.out.println(\"StaticSingleton is create\"); //创建单例的过程可能会比较慢 } private static class SingletonHolder{ private static StaticSingleton instance = new StaticSingleton(); } public static StaticSingleton getInstance(){ return SingletonHolder.instance; }} 在这个实现中，单例模式使用内部类来维护单例实例，当StaticSingleton被加载时，其内部类并不会被初始化，故可以确保当StaticSingleton被载入JVM时，不会初始化单例类，而当getInstance()方法被调用时，才会加载SingletonHolder，从而初始化instance。同时，由于实例的建立是在类加载时完成，故天生对多线程友好，getInstance()方法不需要使用同步关键字。因此，这种实现方式同时兼备以上两种实现优点。 使用内部类的方式实现单例，既可以做到延迟加载，也不必使用同步关键字，是一种比较完善的实现 通常情况下，用以上实现的单例已经可以确保在系统中只存在唯一实例了。但仍然有例外情况，可能导致系统生成很多个实例，比如，在代码中，通过反射机制，强行调用单例类的私有构造函数，生成多个单例。 一个可以序列化的单例 点击展开代码 >folded123456789101112131415161718public class SerSingleton implements java.io.Serializable{ String name; private SerSingleton(){ System.out.println(\"SerSingleton is create\"); //创建单例的过程可能会比较慢 name = \"SerSingleton\"; } private static SerSingleton instance = new SerSingleton(); public static SerSingleton getInstance(){ return instance; } public static void createSting(){ System.out.println(\"createString in Singleton\"); } private Object readResolve(){ // 阻止生成新的实例，总是返回当前对象 return instance; }} 测试代码如下： 点击展开代码 >folded1234567891011121314151617@Testpublic void test() throws Exception{ SerSingleton s1 = null; SerSingleton s = SerSingleton.getInstance(); //先将实例序列化到文件 FileOutputSteam fos = new FileOutputStream(\"SerSingleton.txt\"); ObjectOutputStream oos = new ObjectOutputStream(fos); oos.writeObject(s); oos.flush; oos.close; // 从文件读出原有的单例类 FileInputStream fis = new FileInputStream(\"SerSingleton.txt\"); ObjectInputStream ois = new ObjectInputStream(fis); s1 = (SerSingleton)ois.readObject(); Assert.assertEquals(s,s1);} 使用一段测试单例的序列化和反序列化，当去掉SerSingleton代码中的readResolve()方法时，抛出异常，s和s1不是同一实例,反序列化后，生成多个对象实例。添加readResolve()方法后，程序未报异常。说明，即便是反序列化，仍然保持了单例的特性。实现了私有的readResolve()方法后，readObject()已经形同虚设，它直接使用readResolve()方法替换了原本的返回值，从而在形式上构造了单例。 序列化和反序列化可能会破坏单例。一般来说，对单例进行序列化和反序列化的场景不多见，如果存在就需要多加注意。 参考文章: Java程序性能优化","link":"/2020/05/13/singleton/"},{"title":"linux查询端口占用","text":"部署服务时经常使用到的linux命令 点击展开代码 >unfolded123456# 查询端口占用netstat -lnpt |grep 5672# 查看进程的详细信息 xxxx表示PIDps xxxx # 中止进程,xxxx表示PIDkill -9 xxxx","link":"/2020/05/07/linux-code-1/"},{"title":"linux端口放行","text":"配置某个服务端口时，查询端口是否开发等一些相关操作 点击展开代码 >unfolded12345678910111213141516# 开放xxxx端口 firewall-cmd --zone=public --add-port=xxxx/tcp --permanent # 设置生效 firewall-cmd --reload# 关闭xxxx端口 firewall-cmd --zone=public --remove-port=xxxx/tcp --permanent# 查看防火墙所有开放的端口 firewall-cmd --zone=public --list-ports# 关闭防火墙 systemctl stop firewalld.service# 查看防火墙状态 firewall-cmd --state# 查询xxxx端口是否开启成功 firewall-cmd --query-port=xxxx/tcp # 查看监听的端口 netstat -lnpt","link":"/2020/05/07/linux-code/"},{"title":"Java基础-异常","text":"Java 异常类层次结构? 转载于：https://www.pdai.tech/md/interview/x-interview.html#13-%E6%B3%A8%E8%A7%A3著作权归https://pdai.tech所有。 链接：https://www.pdai.tech/md/interview/x-interview.html Throwable 是 Java 语言中所有错误与异常的超类。 Error 类及其子类：程序中无法处理的错误，表示运行应用程序中出现了严重的错误。 Exception 程序本身可以捕获并且可以处理的异常。Exception 这种异常又分为两类：运行时异常和编译时异常。 运行时异常都是RuntimeException类及其子类异常，如NullPointerException(空指针异常)、IndexOutOfBoundsException(下标越界异常)等，这些异常是不检查异常，程序中可以选择捕获处理，也可以不处理。这些异常一般是由程序逻辑错误引起的，程序应该从逻辑角度尽可能避免这类异常的发生。运行时异常的特点是 Java 编译器不会检查它，也就是说，当程序中可能出现这类异常，即使没有用 try-catch 语句捕获它，也没有用throws子句声明抛出它，也会编译通过。 非运行时异常 （编译异常）是RuntimeException以外的异常，类型上都属于Exception类及其子类。从程序语法角度讲是必须进行处理的异常，如果不处理，程序就不能编译通过。如IOException、SQLException等以及用户自定义的 Exception 异常，一般情况下不自定义检查异常。 可查的异常（checked exceptions）和不可查的异常（unchecked exceptions）区别？可查异常（编译器要求必须处置的异常）：正确的程序在运行中，很容易出现的、情理可容的异常状况。可查异常虽然是异常状况，但在一定程度上它的发生是可以预计的，而且一旦发生这种异常状况，就必须采取某种方式进行处理。除了RuntimeException及其子类以外，其他的Exception类及其子类都属于可查异常。这种异常的特点是 Java 编译器会检查它，也就是说，当程序中可能出现这类异常，要么用try-catch语句捕获它，要么用throws子句声明抛出它，否则编译不会通过。 不可查异常(编译器不要求强制处置的异常)包括运行时异常（RuntimeException与其子类）和错误（Error）。 throw和throws的区别？异常的申明(throws)在 Java 中，当前执行的语句必属于某个方法，Java 解释器调用main方法执行开始执行程序。若方法中存在检查异常，如果不对其捕获，那必须在方法头中显式声明该异常，以便于告知方法调用者此方法有异常，需要进行处理。 在方法中声明一个异常，方法头中使用关键字throws，后面接上要声明的异常。若声明多个异常，则使用逗号分割。如下所示： 123public static void method() throws IOException, FileNotFoundException{ //something statements} 异常的抛出(throw)如果代码可能会引发某种错误，可以创建一个合适的异常类实例并抛出它，这就是抛出异常。如下所示： 123456public static double method(int value) { if(value == 0) { throw new ArithmeticException(\"参数不能为0\"); //抛出一个运行时异常 } return 5.0 / value;} Java 7 的 try-with-resource?如果你的资源实现了 AutoCloseable 接口，你可以使用这个语法。大多数的 Java 标准资源都继承了这个接口。当你在 try 子句中打开资源，资源会在 try 代码块执行后或异常处理后自动关闭。 异常的底层？提到 JVM 处理异常的机制，就需要提及 Exception Table，以下称为异常表。我们暂且不急于介绍异常表，先看一个简单的 Java 处理异常的小例子。 1234567public static void simpleTryCatch() { try { testNPE(); } catch (Exception e) { e.printStackTrace(); }} 使用 javap 来分析这段代码（需要先使用 javac 编译） 123456789101112//javap -c Main public static void simpleTryCatch(); Code: 0: invokestatic #3 // Method testNPE:()V 3: goto 11 6: astore_0 7: aload_0 8: invokevirtual #5 // Method java/lang/Exception.printStackTrace:()V 11: return Exception table: from to target type 0 3 6 Class java/lang/Exception 看到上面的代码，应该会有会心一笑，因为终于看到了 Exception table，也就是我们要研究的异常表。 异常表中包含了一个或多个异常处理者(Exception Handler)的信息，这些信息包含如下 from 可能发生异常的起始点 to 可能发生异常的结束点 target 上述 from 和 to 之前发生异常后的异常处理者的位置 type 异常处理者处理的异常的类信息 转载面试","link":"/2022/07/25/gmrl14/"},{"title":"Java基础-泛型","text":"为什么需要泛型？ 转载于：https://www.pdai.tech/md/interview/x-interview.html#12-%E6%B3%9B%E5%9E%8B著作权归https://pdai.tech所有。 链接：https://www.pdai.tech/md/interview/x-interview.html 1.适用于多种数据类型执行相同的代码1234567891011121314private static int add(int a, int b) { System.out.println(a + \"+\" + b + \"=\" + (a + b)); return a + b;}private static float add(float a, float b) { System.out.println(a + \"+\" + b + \"=\" + (a + b)); return a + b;}private static double add(double a, double b) { System.out.println(a + \"+\" + b + \"=\" + (a + b)); return a + b;} 如果没有泛型，要实现不同类型的加法，每种类型都需要重载一个 add 方法；通过泛型，我们可以复用为一个方法： 1234private static &lt;T extends Number&gt; double add(T a, T b) { System.out.println(a + \"+\" + b + \"=\" + (a.doubleValue() + b.doubleValue())); return a.doubleValue() + b.doubleValue();} 2.泛型中的类型在使用时指定，不需要强制类型转换（类型安全，编译器会检查类型）看下这个例子： 1234List list = new ArrayList();list.add(\"xxString\");list.add(100d);list.add(new Person()); 我们在使用上述 list 中，list 中的元素都是 Object 类型（无法约束其中的类型），所以在取出集合元素时需要人为的强制类型转化到具体的目标类型，且很容易出现 java.lang.ClassCastException 异常。引入泛型，它将提供类型的约束，提供编译前的检查： 123List&lt;String&gt; list = new ArrayList&lt;String&gt;();// list中只能放String, 不能放其它类型的元素 泛型类如何定义使用？从一个简单的泛型类看起：12345678910111213141516class Point&lt;T&gt;{ // 此处可以随便写标识符号，T是type的简称 private T var ; // var的类型由T指定，即：由外部指定 public T getVar(){ // 返回值的类型由外部决定 return var ; } public void setVar(T var){ // 设置的类型也由外部决定 this.var = var ; }}public class GenericsDemo06{ public static void main(String args[]){ Point&lt;String&gt; p = new Point&lt;String&gt;() ; // 里面的var类型为String类型 p.setVar(\"it\") ; // 设置字符串 System.out.println(p.getVar().length()) ; // 取得字符串的长度 }} 多元泛型123456789101112131415161718192021222324252627class Notepad&lt;K,V&gt;{ // 此处指定了两个泛型类型 private K key ; // 此变量的类型由外部决定 private V value ; // 此变量的类型由外部决定 public K getKey(){ return this.key ; } public V getValue(){ return this.value ; } public void setKey(K key){ this.key = key ; } public void setValue(V value){ this.value = value ; }}public class GenericsDemo09{ public static void main(String args[]){ Notepad&lt;String,Integer&gt; t = null ; // 定义两个泛型类型的对象 t = new Notepad&lt;String,Integer&gt;() ; // 里面的key为String，value为Integer t.setKey(\"汤姆\") ; // 设置第一个内容 t.setValue(20) ; // 设置第二个内容 System.out.print(\"姓名；\" + t.getKey()) ; // 取得信息 System.out.print(\"，年龄；\" + t.getValue()) ; // 取得信息 }} 泛型接口如何定义使用？简单的泛型接口12345678910111213141516171819202122interface Info&lt;T&gt;{ // 在接口上定义泛型 public T getVar() ; // 定义抽象方法，抽象方法的返回值就是泛型类型}class InfoImpl&lt;T&gt; implements Info&lt;T&gt;{ // 定义泛型接口的子类 private T var ; // 定义属性 public InfoImpl(T var){ // 通过构造方法设置属性内容 this.setVar(var) ; } public void setVar(T var){ this.var = var ; } public T getVar(){ return this.var ; }}public class GenericsDemo24{ public static void main(String arsg[]){ Info&lt;String&gt; i = null; // 声明接口对象 i = new InfoImpl&lt;String&gt;(\"汤姆\") ; // 通过子类实例化对象 System.out.println(\"内容：\" + i.getVar()) ; }} 泛型方法如何定义使用？泛型方法，是在调用方法的时候指明泛型的具体类型 定义泛型方法语法格式 调用泛型方法语法格式 说明一下，定义泛型方法时，必须在返回值前边加一个&lt;T&gt;，来声明这是一个泛型方法，持有一个泛型T，然后才可以用泛型T作为方法的返回值。Class&lt;T&gt;的作用就是指明泛型的具体类型，而Class&lt;T&gt;类型的变量 c，可以用来创建泛型类的对象。为什么要用变量c来创建对象呢？既然是泛型方法，就代表着我们不知道具体的类型是什么，也不知道构造方法如何，因此没有办法去new一个对象，但可以利用变量c的newInstance方法去创建对象，也就是利用反射创建对象。泛型方法要求的参数是Class&lt;T&gt;类型，而Class.forName()方法的返回值也是Class&lt;T&gt;，因此可以用Class.forName()作为参数。其中，forName()方法中的参数是何种类型，返回的Class&lt;T&gt;就是何种类型。在本例中，forName()方法中传入的是User类的完整路径，因此返回的是Class&lt;User&gt;类型的对象，因此调用泛型方法时，变量c的类型就是Class&lt;User&gt;，因此泛型方法中的泛型T就被指明为User，因此变量obj的类型为User。当然，泛型方法不是仅仅可以有一个参数Class&lt;T&gt;，可以根据需要添加其他参数。为什么要使用泛型方法呢？因为泛型类要在实例化的时候就指明类型，如果想换一种类型，不得不重新new一次，可能不够灵活；而泛型方法可以在调用的时候指明类型，更加灵活。 泛型的上限和下限？在使用泛型的时候，我们可以为传入的泛型类型实参进行上下边界的限制，如：类型实参只准传入某种类型的父类或某种类型的子类。 上限1234567891011121314151617class Info&lt;T extends Number&gt;{ // 此处泛型只能是数字类型 private T var ; // 定义泛型变量 public void setVar(T var){ this.var = var ; } public T getVar(){ return this.var ; } public String toString(){ // 直接打印 return this.var.toString() ; }}public class demo1{ public static void main(String args[]){ Info&lt;Integer&gt; i1 = new Info&lt;Integer&gt;() ; // 声明Integer的泛型对象 }} 下限12345678910111213141516171819202122232425class Info&lt;T&gt;{ private T var ; // 定义泛型变量 public void setVar(T var){ this.var = var ; } public T getVar(){ return this.var ; } public String toString(){ // 直接打印 return this.var.toString() ; }}public class GenericsDemo21{ public static void main(String args[]){ Info&lt;String&gt; i1 = new Info&lt;String&gt;() ; // 声明String的泛型对象 Info&lt;Object&gt; i2 = new Info&lt;Object&gt;() ; // 声明Object的泛型对象 i1.setVar(\"hello\") ; i2.setVar(new Object()) ; fun(i1) ; fun(i2) ; } public static void fun(Info&lt;? super String&gt; temp){ // 只能接收String或Object类型的泛型，String类的父类只有Object类 System.out.print(temp + \", \") ; }} 如何理解 Java 中的泛型是伪泛型？泛型中类型擦除 Java 泛型这个特性是从 JDK 1.5 才开始加入的，因此为了兼容之前的版本，Java 泛型的实现采取了“伪泛型”的策略，即 Java 在语法上支持泛型，但是在编译阶段会进行所谓的“类型擦除”（Type Erasure），将所有的泛型表示（尖括号中的内容）都替换为具体的类型（其对应的原生态类型），就像完全没有泛型一样。 转载面试","link":"/2022/07/21/nbzv8i/"},{"title":"Java基础-注解","text":"注解的作用？ 转载于：https://www.pdai.tech/md/interview/x-interview.html#13-%E6%B3%A8%E8%A7%A3著作权归https://pdai.tech所有。 链接：https://www.pdai.tech/md/interview/x-interview.html 注解是 JDK1.5 版本开始引入的一个特性，用于对代码进行说明，可以对包、类、接口、字段、方法参数、局部变量等进行注解。它主要的作用有以下四方面： 生成文档，通过代码里标识的元数据生成 javadoc 文档。 编译检查，通过代码里标识的元数据让编译器在编译期间进行检查验证。 编译时动态处理，编译时通过代码里标识的元数据动态处理，例如动态生成代码。 运行时动态处理，运行时通过代码里标识的元数据动态处理，例如使用反射注入实例。 注解的常见分类？Java 自带的标准注解 包括@Override、@Deprecated和@SuppressWarnings，分别用于标明重写某个方法、标明某个类或方法过时、标明要忽略的警告，用这些注解标明后编译器就会进行检查。 元注解 元注解是用于定义注解的注解，包括@Retention、@Target、@Inherited、@Documented @Retention用于标明注解被保留的阶段 @Target用于标明注解使用的范围 @Inherited用于标明注解可继承 @Documented用于标明是否生成 javadoc 文档 自定义注解 可以根据自己的需求定义注解，并可用元注解对自定义注解进行注解。 转载面试","link":"/2022/07/21/zvn4dc/"},{"title":"linux命令","text":"一些有用的 linux 命令 系统 123456789uname -a # 查看内核、操作系统、cpu信息head -n 1 /etc/issue # 查看操作系统版本cat /proc/cpuinfo # 查看cpu信息hostname # 查看计算机名lspci -tv # 列出所有PCI设备（需要yum install pciutils）lsusb -tv # 列出所有USB设备lsmod # 列出加载的内核模块env # 查看环境变量lspci | grep Ethernet # 查看网卡型号 资源 1234567free -m # 查看内存使用量和交换区使用量df -h # 查看各分区使用情况du -sh &lt;目录名&gt; # 查看指定目录的大小grep MemTotal /proc/meminfo # 查看内存总量grep MemFree /proc/meminfo # 查看空闲内存量uptime # 查看系统运行时间、用户数、负载cat /proc/loadavg # 查看系统负载 磁盘和分区 12345mount | column -t # 查看挂接的分区状态fdisk -l # 查看所有分区swapon -s # 查看所有交换分区hdparm -i /dev/hda # 查看磁盘参数(仅适用于IDE设备)dmesg | grep IDE # 查看启动时IDE设备检测状况 网络 123456ifconfig # 查看所有网络接口的属性iptables -L # 查看防火墙设置route -n # 查看路由表netstat -lntp # 查看所有监听端口netstat -antp # 查看所有已经建立的连接netstat -s # 查看网络统计信息 进程 12ps -ef # 查看所有进程top # 实时显示进程状态 程序 1pm -qa # 查看所有安装的软件包 服务 12chkconfig --list # 列出所有系统服务chkconfig --list | grep on # 列出所有启动的系统服务","link":"/2020/04/28/fotwg6/"},{"title":"Java基础-语法基础","text":"面向对象特性? 转载于：https://www.pdai.tech/md/interview/x-interview.html#11-%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%80著作权归https://pdai.tech所有。 链接：https://www.pdai.tech/md/interview/x-interview.html 封装利用抽象数据类型将数据和基于数据的操作封装在一起，使其构成一个不可分割的独立实体。数据被保护在抽象数据类型的内部，尽可能地隐藏内部的细节，只保留一些对外接口使之与外部发生联系。用户无需知道对象内部的细节，但可以通过对象对外提供的接口来访问该对象。优点: 减少耦合: 可以独立地开发、测试、优化、使用、理解和修改 减轻维护的负担: 可以更容易被程序员理解，并且在调试的时候可以不影响其他模块 有效地调节性能: 可以通过剖析确定哪些模块影响了系统的性能 提高软件的可重用性 降低了构建大型系统的风险: 即使整个系统不可用，但是这些独立的模块却有可能是可用的 以下 Person 类封装 name、gender、age 等属性，外界只能通过 get() 方法获取一个 Person 对象的 name 属性和 gender 属性，而无法获取 age 属性，但是 age 属性可以供 work() 方法使用。注意到 gender 属性使用 int 数据类型进行存储，封装使得用户注意不到这种实现细节。并且在需要修改 gender 属性使用的数据类型时，也可以在不影响客户端代码的情况下进行。 12345678910111213141516171819202122public class Person { private String name; private int gender; private int age; public String getName() { return name; } public String getGender() { return gender == 0 ? \"man\" : \"woman\"; } public void work() { if (18 &lt;= age &amp;&amp; age &lt;= 50) { System.out.println(name + \" is working very hard!\"); } else { System.out.println(name + \" can't work any more!\"); } }} 继承继承实现了 IS-A 关系，例如 Cat 和 Animal 就是一种 IS-A 关系，因此 Cat 可以继承自 Animal，从而获得 Animal 非 private 的属性和方法。继承应该遵循里氏替换原则，子类对象必须能够替换掉所有父类对象。Cat 可以当做 Animal 来使用，也就是说可以使用 Animal 引用 Cat 对象。父类引用指向子类对象称为 向上转型 。 1Animal animal = new Cat(); 多态多态分为编译时多态和运行时多态: 编译时多态主要指方法的重载 运行时多态指程序中定义的对象引用所指向的具体类型在运行期间才确定 运行时多态有三个条件: 继承 覆盖(重写) 向上转型 下面的代码中，乐器类(Instrument)有两个子类: Wind 和 Percussion，它们都覆盖了父类的 play() 方法，并且在 main() 方法中使用父类 Instrument 来引用 Wind 和 Percussion 对象。在 Instrument 引用调用 play() 方法时，会执行实际引用对象所在类的 play() 方法，而不是 Instrument 类的方法。 12345678910111213141516171819202122232425262728public class Instrument { public void play() { System.out.println(\"Instrument is playing...\"); }}public class Wind extends Instrument { public void play() { System.out.println(\"Wind is playing...\"); }}public class Percussion extends Instrument { public void play() { System.out.println(\"Percussion is playing...\"); }}public class Music { public static void main(String[] args) { List&lt;Instrument&gt; instruments = new ArrayList&lt;&gt;(); instruments.add(new Wind()); instruments.add(new Percussion()); for(Instrument instrument : instruments) { instrument.play(); } }} a = a + b 与 a += b 的区别+= 隐式的将加操作的结果类型强制转换为持有结果的类型。如果两个整型相加，如 byte、short 或者 int，首先会将它们提升到 int 类型，然后在执行加法操作。 1234byte a = 127;byte b = 127;b = a + b; // error : cannot convert from int to byteb += a; // ok (因为 a+b 操作会将 a、b 提升为 int 类型，所以将 int 类型赋值给 byte 就会编译出错) 3*0.1 == 0.3 将会返回什么? true 还是 false?false，因为有些浮点数不能完全精确的表示出来。 能在 Switch 中使用 String 吗?从 Java 7 开始，我们可以在 switch case 中使用字符串，但这仅仅是一个语法糖。内部实现在 switch 中使用字符串的 hash code。 对 equals()和 hashCode()的理解? 为什么在重写 equals 方法的时候需要重写 hashCode 方法? 因为有强制的规范指定需要同时重写 hashcode 与 equals 是方法，许多容器类，如 HashMap、HashSet 都依赖于 hashcode 与 equals 的规定。 有没有可能两个不相等的对象有相同的 hashcode? 有可能，两个不相等的对象可能会有相同的 hashcode 值，这就是为什么在 hashmap 中会有冲突。相等 hashcode 值的规定只是说如果两个对象相等，必须有相同的 hashcode 值，但是没有关于不相等对象的任何规定。 两个相同的对象会有不同的 hash code 吗? 不能，根据 hash code 的规定，这是不可能的。 final、finalize 和 finally 的不同之处? final 是一个修饰符，可以修饰变量、方法和类。如果 final 修饰变量，意味着该变量的值在初始化后不能被改变。 Java 技术允许使用 finalize() 方法在垃圾收集器将对象从内存中清除出去之前做必要的清理工作。这个方法是由垃圾收集器在确定这个对象没有被引用时对这个对象调用的，但是什么时候调用 finalize 没有保证。 finally 是一个关键字，与 try 和 catch 一起用于异常的处理。finally 块一定会被执行，无论在 try 块中是否有发生异常。 String、StringBuffer 与 StringBuilder 的区别？第一点: 可变和适用范围。String 对象是不可变的，而 StringBuffer 和 StringBuilder 是可变字符序列。每次对 String 的操作相当于生成一个新的 String 对象，而对 StringBuffer 和 StringBuilder 的操作是对对象本身的操作，而不会生成新的对象，所以对于频繁改变内容的字符串避免使用 String，因为频繁的生成对象将会对系统性能产生影响。第二点: 线程安全。String 由于有 final 修饰，是 immutable 的，安全性是简单而纯粹的。StringBuilder 和 StringBuffer 的区别在于 StringBuilder 不保证同步，也就是说如果需要线程安全需要使用 StringBuffer，不需要同步的 StringBuilder 效率更高。 接口与抽象类的区别？ 一个子类只能继承一个抽象类, 但能实现多个接口 抽象类可以有构造方法, 接口没有构造方法 抽象类可以有普通成员变量, 接口没有普通成员变量 抽象类和接口都可有静态成员变量, 抽象类中静态成员变量访问类型任意，接口只能 public static final(默认) 抽象类可以没有抽象方法, 抽象类可以有普通方法；接口在 JDK8 之前都是抽象方法，在 JDK8 可以有 default 方法，在 JDK9 中允许有私有普通方法 抽象类可以有静态方法；接口在 JDK8 之前不能有静态方法，在 JDK8 中可以有静态方法，且只能被接口类直接调用（不能被实现类的对象调用） 抽象类中的方法可以是 public、protected; 接口方法在 JDK8 之前只有 public abstract，在 JDK8 可以有 default 方法，在 JDK9 中允许有 private 方法 this() &amp; super()在构造方法中的区别？ 调用 super()必须写在子类构造方法的第一行, 否则编译不通过 super 从子类调用父类构造, this 在同一类中调用其他构造均需要放在第一行 尽管可以用 this 调用一个构造器, 却不能调用 2 个 this 和 super 不能出现在同一个构造器中, 否则编译不通过 this()、super()都指的对象,不可以在 static 环境中使用 本质 this 指向本对象的指针。super 是一个关键字 Java 移位运算符？java 中有三种移位运算符 &lt;&lt; :左移运算符,x &lt;&lt; 1,相当于 x 乘以 2(不溢出的情况下),低位补 0 &gt;&gt; :带符号右移,x &gt;&gt; 1,相当于 x 除以 2,正数高位补 0,负数高位补 1 &gt;&gt;&gt; :无符号右移,忽略符号位,空位都以 0 补齐 转载面试","link":"/2022/07/20/gpdsgr/"},{"title":"博客第一期","text":"该博客模版案例来自 @蚂蚁金服体验技术部 插入带链接的标题（ctrl+K）Best Year in Music这幅可视化作品展示了 1960 年以来，Billboard 历年榜单的前五名音乐的变化情况，效果呈现设计感十足，还可以在聆听音乐的同时回顾音乐的变迁史。插入图片，点击图片，设置图片大小值得一提的是，作者正是大名鼎鼎的数据新闻站点 The Pudding。作为可视化新闻媒体中的姣姣者，The Pudding 擅长对那些兼具信息量和娱乐度的争议性话题进行可视化呈现，来使得复杂的观点变得更容易被公众理解。该团队虽然仅由数名全职记者和工程师组成，但战斗力强悍，目前已有数十个大型的数据可视化作品。输入作者 @诸岳(dengfuping) Road Suffixes in the USA美国道路命名多种多样，例如著名的纽约第五大道（Fifth Avenue），又或者凤凰城（Phoenix）的 Washington Street，Thomas Road，Union Hill Drive 等。不同的道路，有不同的叫法，Avenue, Street, Road, Drive 等等。想了解更多关于美国道路命名可以参考这篇文章。作者用 R 语言统计了美国每个县的每种道路后缀（例如 Avenue）的总里程，并把每个县总里程最大的道路后缀通过颜色映射到地图上。可以看出美国大部分县的道路都是以 Rd(Road 的缩写)结尾的。插入图片，点击图片，设置图片大小 另外还以柱状图的方式展示了每种道路后缀的总里程（英里）：by @长哲(changzhe) 「加餐」Hello World 图可视化图可视化是信息可视化的子领域，它通过展示元素、关系，帮助用户获取数据的洞悉能力。它已被广泛地应用在流程图、社交网络、英特网、蛋白质网络等关系数据的呈现。本文由 AntV 团队 @十吾(shiwu-5wap2) 👆 撰写，参考自[1][2]两篇图可视化学术论文，简要介绍图可视化的历史、背景、机遇与挑战。","link":"/2020/04/22/ny150b/"},{"title":"测试一下font-formatter","text":"测试语雀 front-matter 没有内容了","link":"/2020/04/22/wvwguf/"},{"title":"面试官问分布式技术面试题，一脸懵逼怎么办?","text":"分布式缓存，分布式消息队列，分布式服务框架** 转载于：https://my.oschina.net/u/3728792/blog/3042368 1.分布式缓存1.1 Redis 有什么数据类型？分别用于什么场景？ 数据类型 可以存储的值 操作 STRING 字符串、整数或者浮点数 对整个字符串或者字符串的其中一部分执行操作 对整数和浮点数执行自增或者自减操作 LIST 列表 从两端压入或者弹出元素 读取单个或者多个元素进行修剪，只保留一个范围内的元素 || SET | 无序集合 | 添加、获取、移除单个元素检查一个元素是否存在于集合中计算交集、并集、差集从集合里面随机获取元素 || HASH | 包含键值对的无序散列表 | 添加、获取、移除单个键值对获取所有键值对检查某个键是否存在 || ZSET | 有序集合 | 添加、获取、删除元素根据分值范围或者成员来获取元素计算一个键的排名 | 详细文档：https://redislabs.com/ebook/part-1-getting-started/chapter-1-getting-to-know-redis/1-2-what-redis-data-structures-look-like/ 1.2. Redis 的主从复制是如何实现的？ 从服务器连接主服务器，发送 SYNC 命令； 主服务器接收到 SYNC 命名后，开始执行 BGSAVE 命令生成 RDB 文件并使用缓冲区记录此后执行的所有写命令； 主服务器 BGSAVE 执行完后，向所有从服务器发送快照文件，并在发送期间继续记录被执行的写命令； 从服务器收到快照文件后丢弃所有旧数据，载入收到的快照； 主服务器快照发送完毕后开始向从服务器发送缓冲区中的写命令； 从服务器完成对快照的载入，开始接收命令请求，并执行来自主服务器缓冲区的写命令； 1.3. Redis 的 key 是如何寻址的？背景 （1）redis 中的每一个数据库，都由一个 redisDb 的结构存储。其中： redisDb.id 存储着 redis 数据库以整数表示的号码。 redisDb.dict 存储着该库所有的键值对数据。 redisDb.expires 保存着每一个键的过期时间。 （2）当 redis 服务器初始化时，会预先分配 16 个数据库（该数量可以通过配置文件配置），所有数据库保存到结构 redisServer的一个成员 redisServer.db 数组中。当我们选择数据库 select number 时，程序直接通过redisServer.db[number] 来切换数据库。有时候当程序需要知道自己是在哪个数据库时，直接读取 redisDb.id 即可。（3）redis 的字典使用哈希表作为其底层实现。dict 类型使用的两个指向哈希表的指针，其中 0号哈希表（ht[0]）主要用于存储数据库的所有键值，而 1 号哈希表主要用于程序对 0 号哈希表进行 rehash 时使用，rehash一般是在添加新值时会触发，这里不做过多的赘述。所以 redis 中查找一个 key，其实就是对进行该 dict 结构中的 ht[0]进行查找操作。（4）既然是哈希，那么我们知道就会有哈希碰撞，那么当多个键哈希之后为同一个值怎么办呢？redis采取链表的方式来存储多个哈希碰撞的键。也就是说，当根据 key 的哈希值找到该列表后，如果列表的长度大于1，那么我们需要遍历该链表来找到我们所查找的 key。当然，一般情况下链表长度都为是 1，所以时间复杂度可看作 o(1)。 寻址 key 的步骤 当拿到一个 key 后，redis 先判断当前库的 0 号哈希表是否为空，即：if (dict-&gt;ht[0].size == 0)。如果为 true 直接返回 NULL。 判断该 0 号哈希表是否需要 rehash，因为如果在进行 rehash，那么两个表中者有可能存储该 key。如果正在进行rehash，将调用一次_dictRehashStep 方法，_dictRehashStep 用于对数据库字典、以及哈希键的字典进行被动rehash，这里不作赘述。 计算哈希表，根据当前字典与 key 进行哈希值的计算。 根据哈希值与当前字典计算哈希表的索引值。 根据索引值在哈希表中取出链表，遍历该链表找到 key 的位置。一般情况，该链表长度为 1。 当 ht[0] 查找完了之后，再进行了次 rehash 判断，如果未在 rehashing，则直接结束，否则对 ht[1]重复 345 步骤。 1.4. Redis 的集群模式是如何实现的？ Redis Cluster 是 Redis 的分布式解决方案，在 Redis 3.0 版本正式推出的。Redis Cluster 去中心化，每个节点保存数据和整个集群状态，每个节点都和其他所有节点连接。 Redis Cluster 节点分配 Redis Cluster 特点： 所有的 redis 节点彼此互联(PING-PONG 机制)，内部使用二进制协议优化传输速度和带宽。 节点的 fail 是通过集群中超过半数的节点检测失效时才生效。 客户端与 redis 节点直连,不需要中间 proxy 层。客户端不需要连接集群所有节点，连接集群中任何一个可用节点即可。 redis-cluster 把所有的物理节点映射到[0-16383] 哈希槽 (hash slot)上（不一定是平均分配）,cluster 负责维护 node、slot、value。 Redis 集群预分好 16384 个桶，当需要在 Redis 集群中放置一个 key-value 时，根据 CRC16(key) mod 16384 的值，决定将一个 key 放到哪个桶中。 Redis Cluster 主从模式 Redis Cluster 为了保证数据的高可用性，加入了主从模式。一个主节点对应一个或多个从节点，主节点提供数据存取，从节点则是从主节点拉取数据备份。当这个主节点挂掉后，就会有这个从节点选取一个来充当主节点，从而保证集群不会挂掉。所以，在集群建立的时候，一定要为每个主节点都添加了从节点。 Redis Sentinel Redis Sentinel 用于管理多个 Redis 服务器，它有三个功能： 监控（Monitoring） - Sentinel 会不断地检查你的主服务器和从服务器是否运作正常。 提醒（Notification） - 当被监控的某个 Redis 服务器出现问题时， Sentinel 可以通过 API 向管理员或者其他应用程序发送通知。 自动故障迁移（Automatic failover） - 当一个主服务器不能正常工作时，Sentinel 会开始一次自动故障迁移操作， 它会将失效主服务器的其中一个从服务器升级为新的主服务器，并让失效主服务器的其他从服务器改为复制新的主服务器； 当客户端试图连接失效的主服务器时， 集群也会向客户端返回新主服务器的地址，使得集群可以使用新主服务器代替失效服务器。 12345678910Redis 集群中应该有奇数个节点，所以至少有三个节点。哨兵监控集群中的主服务器出现故障时，需要根据 quorum 选举出一个哨兵来执行故障转移。选举需要majority，即大多数哨兵是运行的（2 个哨兵的 majority=2，3 个哨兵的 majority=2，5 个哨兵的majority=3，4 个哨兵的 majority=2）。假设集群仅仅部署 2 个节点+----+ +----+| M1 |---------| R1 || S1 | | S2 |+----+ +----+如果 M1 和 S1 所在服务器宕机，则哨兵只有 1 个，无法满足 majority 来进行选举，就不能执行故障转移。 1.5. Redis 如何实现分布式锁？ZooKeeper 如何实现分布式锁？比较二者优劣？ 分布式锁的三种实现： 基于数据库实现分布式锁； 基于缓存（Redis 等）实现分布式锁； 基于 Zookeeper 实现分布式锁； 数据库实现Redis 实现 获取锁的时候，使用 setnx 加锁，并使用 expire 命令为锁添加一个超时时间，超过该时间则自动释放锁，锁的 value 值为一个随机生成的 UUID，通过此在释放锁的时候进行判断。 获取锁的时候还设置一个获取的超时时间，若超过这个时间则放弃获取锁。 释放锁的时候，通过 UUID 判断是不是该锁，若是该锁，则执行 delete 进行锁释放。 ZooKeeper 实现 创建一个目录 mylock； 线程 A 想获取锁就在 mylock 目录下创建临时顺序节点； 获取 mylock 目录下所有的子节点，然后获取比自己小的兄弟节点，如果不存在，则说明当前线程顺序号最小，获得锁； 线程 B 获取所有节点，判断自己不是最小节点，设置监听比自己次小的节点； 线程 A 处理完，删除自己的节点，线程 B 监听到变更事件，判断自己是不是最小的节点，如果是则获得锁。 实现对比 ZooKeeper 具备高可用、可重入、阻塞锁特性，可解决失效死锁问题。 但 ZooKeeper 因为需要频繁的创建和删除节点，性能上不如 Redis 方式。 1.6. Redis 的持久化方式？有什么优缺点？持久化实现原理？RDB 快照（snapshot） 将存在于某一时刻的所有数据都写入到硬盘中。快照的原理在默认情况下，Redis 将数据库快照保存在名字为 dump.rdb 的二进制文件中。你可以对 Redis 进行设置， 让它在“N秒内数据集至少有 M 个改动”这一条件被满足时， 自动保存一次数据集。你也可以通过调用 SAVE 或者 BGSAVE，手动让 Redis进行数据集保存操作。这种持久化方式被称为快照。当 Redis 需要保存 dump.rdb 文件时， 服务器执行以下操作: Redis 创建一个子进程。 子进程将数据集写入到一个临时快照文件中。 当子进程完成对新快照文件的写入时，Redis 用新快照文件替换原来的快照文件，并删除旧的快照文件。 这种工作方式使得 Redis 可以从写时复制（copy-on-write）机制中获益。快照的优点 它保存了某个时间点的数据集，非常适用于数据集的备份。 很方便传送到另一个远端数据中心或者亚马逊的 S3（可能加密），非常适用于灾难恢复。 快照在保存 RDB 文件时父进程唯一需要做的就是 fork 出一个子进程，接下来的工作全部由子进程来做，父进程不需要再做其他 IO 操作，所以快照持久化方式可以最大化 redis 的性能。 与 AOF 相比，在恢复大的数据集的时候，DB 方式会更快一些。 快照的缺点 如果你希望在 redis 意外停止工作（例如电源中断）的情况下丢失的数据最少的话，那么快照不适合你。 快照需要经常 fork 子进程来保存数据集到硬盘上。当数据集比较大的时候，fork 的过程是非常耗时的，可能会导致 Redis 在一些毫秒级内不能响应客户端的请求。 AOF AOF 持久化方式记录每次对服务器执行的写操作。当服务器重启的时候会重新执行这些命令来恢复原始的数据。 AOF 的原理 Redis 创建一个子进程。 子进程开始将新 AOF 文件的内容写入到临时文件。 对于所有新执行的写入命令，父进程一边将它们累积到一个内存缓存中，一边将这些改动追加到现有 AOF 文件的末尾，这样样即使在重写的中途发生停机，现有的 AOF 文件也还是安全的。 当子进程完成重写工作时，它给父进程发送一个信号，父进程在接收到信号之后，将内存缓存中的所有数据追加到新 AOF 文件的末尾。 搞定！现在 Redis 原子地用新文件替换旧文件，之后所有命令都会直接追加到新 AOF 文件的末尾。 AOF 的优点 使用默认的每秒 fsync 策略，Redis 的性能依然很好(fsync 是由后台线程进行处理的,主线程会尽力处理客户端请求)，一旦出现故障，使用 AOF ，你最多丢失 1 秒的数据。 AOF 文件是一个只进行追加的日志文件，所以不需要写入 seek，即使由于某些原因(磁盘空间已满，写的过程中宕机等等)未执行完整的写入命令，你也也可使用 redis-check-aof 工具修复这些问题。 Redis 可以在 AOF 文件体积变得过大时，自动地在后台对 AOF 进行重写：重写后的新 AOF 文件包含了恢复当前数据集所需的最小命令集合。整个重写操作是绝对安全的。 AOF 文件有序地保存了对数据库执行的所有写入操作，这些写入操作以 Redis 协议的格式保存。因此 AOF 文件的内容非常容易被人读懂，对文件进行分析（parse）也很轻松。 AOF 的缺点 对于相同的数据集来说，AOF 文件的体积通常要大于 RDB 文件的体积。 根据所使用的 fsync 策略，AOF 的速度可能会慢于快照。在一般情况下，每秒 fsync 的性能依然非常高，而关闭 fsync可以让 AOF 的速度和快照一样快，即使在高负荷之下也是如此。不过在处理巨大的写入载入时，快照可以提供更有保证的最大延迟时间（latency）。 1.7. Redis 过期策略有哪些？ noeviction - 当内存使用达到阈值的时候，所有引起申请内存的命令会报错。 allkeys-lru - 在主键空间中，优先移除最近未使用的 key。 allkeys-random - 在主键空间中，随机移除某个 key。 volatile-lru - 在设置了过期时间的键空间中，优先移除最近未使用的 key。 volatile-random - 在设置了过期时间的键空间中，随机移除某个 key。 volatile-ttl - 在设置了过期时间的键空间中，具有更早过期时间的 key 优先移除。 1.8. Redis 和 Memcached 有什么区别？ 两者都是非关系型内存键值数据库。有以下主要不同：数据类型 Memcached 仅支持字符串类型； 而 Redis 支持五种不同种类的数据类型，使得它可以更灵活地解决问题。 数据持久化 Memcached 不支持持久化； Redis 支持两种持久化策略：RDB 快照和 AOF 日志。 分布式 Memcached 不支持分布式，只能通过在客户端使用像一致性哈希这样的分布式算法来实现分布式存储，这种方式在存储和查询时都需要先在客户端计算一次数据所在的节点。 Redis Cluster 实现了分布式的支持。 内存管理机制 Memcached 将内存分割成特定长度的块来存储数据，以完全解决内存碎片的问题，但是这种方式会使得内存的利用率不高，例如块的大小为 128 bytes，只存储 100 bytes 的数据，那么剩下的 28 bytes 就浪费掉了。 在 Redis 中，并不是所有数据都一直存储在内存中，可以将一些很久没用的 value 交换到磁盘。而 Memcached 的数据则会一直在内存中。 1.9. 为什么单线程的 Redis 性能反而优于多线程的 Memcached？ Redis 快速的原因： 绝大部分请求是纯粹的内存操作（非常快速） 采用单线程,避免了不必要的上下文切换和竞争条件 非阻塞 IO 内部实现采用 epoll，采用了 epoll+自己实现的简单的事件框架。epoll 中的读、写、关闭、连接都转化成了事件，然后利用 epoll 的多路复用特性，绝不在 io 上浪费一点时间。 2. 分布式消息队列（MQ）2.1. 为什么使用 MQ？ 异步处理 - 相比于传统的串行、并行方式，提高了系统吞吐量。 应用解耦 - 系统间通过消息通信，不用关心其他系统的处理。 流量削锋 - 可以通过消息队列长度控制请求量；可以缓解短时间内的高并发请求。 日志处理 - 解决大量日志传输。 消息通讯 - 消息队列一般都内置了高效的通信机制，因此也可以用在纯的消息通讯。比如实现点对点消息队列，或者聊天室等。 2.2. 如何保证 MQ 的高可用？数据复制 将所有 Broker 和待分配的 Partition 排序 将第 i 个 Partition 分配到第（i mod n）个 Broker 上 将第 i 个 Partition 的第 j 个 Replica 分配到第（(i + j) mode n）个 Broker 上 选举主服务器2.3. MQ 有哪些常见问题？如何解决这些问题？ MQ 的常见问题有： 消息的顺序问题 消息的重复问题 消息的顺序问题 消息有序指的是可以按照消息的发送顺序来消费。假如生产者产生了 2 条消息：M1、M2，假定 M1 发送到 S1，M2 发送到 S2，如果要保证 M1 先于 M2 被消费，怎么做？ 解决方案：（1）保证生产者 - MQServer - 消费者是一对一对一的关系 缺陷： 并行度就会成为消息系统的瓶颈（吞吐量不够） 更多的异常处理，比如：只要消费端出现问题，就会导致整个处理流程阻塞，我们不得不花费更多的精力来解决阻塞的问题。 （2）通过合理的设计或者将问题分解来规避。 不关注乱序的应用实际大量存在 队列无序并不意味着消息无序 所以从业务层面来保证消息的顺序而不仅仅是依赖于消息系统，是一种更合理的方式。 消息的重复问题 造成消息重复的根本原因是：网络不可达。所以解决这个问题的办法就是绕过这个问题。那么问题就变成了：如果消费端收到两条一样的消息，应该怎样处理？消费端处理消息的业务逻辑保持幂等性。只要保持幂等性，不管来多少条重复消息，最后处理的结果都一样。保证每条消息都有唯一编号且保证消息处理成功与去重表的日志同时出现。利用一张日志表来记录已经处理成功的消息的 ID，如果新到的消息 ID已经在日志表中，那么就不再处理这条消息。 2.4. Kafka, ActiveMQ, RabbitMQ, RocketMQ 各有什么优缺点？ 3. 分布式服务（RPC）3.1. Dubbo 的实现过程？节点角色： 节点 角色说明 Provider 暴露服务的服务提供方 Consumer 调用远程服务的服务消费方 Registry 服务注册与发现的注册中心 Monitor 统计服务的调用次数和调用时间的监控中心 Container 服务运行容器 调用关系： 务容器负责启动，加载，运行服务提供者。 服务提供者在启动时，向注册中心注册自己提供的服务。 服务消费者在启动时，向注册中心订阅自己所需的服务。 注册中心返回服务提供者地址列表给消费者，如果有变更，注册中心将基于长连接推送变更数据给消费者。 服务消费者，从提供者地址列表中，基于软负载均衡算法，选一台提供者进行调用，如果调用失败，再选另一台调用。 服务消费者和提供者，在内存中累计调用次数和调用时间，定时每分钟发送一次统计数据到监控中心。 3.2. Dubbo 负载均衡策略有哪些？Random 随机，按权重设置随机概率。 在一个截面上碰撞的概率高，但调用量越大分布越均匀，而且按概率使用权重后也比较均匀，有利于动态调整提供者权重。 RoundRobin 轮循，按公约后的权重设置轮循比率。 存在慢的提供者累积请求的问题，比如：第二台机器很慢，但没挂，当请求调到第二台时就卡在那，久而久之，所有请求都卡在调到第二台上。 LeastActive 最少活跃调用数，相同活跃数的随机，活跃数指调用前后计数差。 使慢的提供者收到更少请求，因为越慢的提供者的调用前后计数差会越大。 ConsistentHash 一致性 Hash，相同参数的请求总是发到同一提供者。 当某一台提供者挂时，原本发往该提供者的请求，基于虚拟节点，平摊到其它提供者，不会引起剧烈变动。 缺省只对第一个参数 Hash，如果要修改，请配置 &lt;dubbo:parameter key=&quot;hash.arguments&quot; value=&quot;0,1&quot; /&gt; 缺省用 160 份虚拟节点，如果要修改，请配置 &lt;dubbo:parameter key=&quot;hash.nodes&quot; value=&quot;320&quot; /&gt; 3.3. Dubbo 集群容错策略 ？ Failover - 失败自动切换，当出现失败，重试其它服务器。通常用于读操作，但重试会带来更长延迟。可通过 retries=”2” 来设置重试次数(不含第一次)。 Failfast - 快速失败，只发起一次调用，失败立即报错。通常用于非幂等性的写操作，比如新增记录。 Failsafe - 失败安全，出现异常时，直接忽略。通常用于写入审计日志等操作。 Failback - 失败自动恢复，后台记录失败请求，定时重发。通常用于消息通知操作。 Forking - 并行调用多个服务器，只要一个成功即返回。通常用于实时性要求较高的读操作，但需要浪费更多服务资源。可通过 forks=”2” 来设置最大并行数。 Broadcast - 播调用所有提供者，逐个调用，任意一台报错则报错。通常用于通知所有提供者更新缓存或日志等本地资源信息。 3.4. 动态代理策略？ Dubbo 作为 RPC 框架，首先要完成的就是跨系统，跨网络的服务调用。消费方与提供方遵循统一的接口定义，消费方调用接口时，Dubbo将其转换成统一格式的数据结构，通过网络传输，提供方根据规则找到接口实现，通过反射完成调用。也就是说，消费方获取的是对远程服务的一个代理(Proxy)，而提供方因为要支持不同的接口实现，需要一个包装层(Wrapper)。调用的过程大概是这样： 消费方的 Proxy 和提供方的 Wrapper 得以让 Dubbo 构建出复杂、统一的体系。而这种动态代理与包装也是通过基于 SPI 的插件方式实现的，它的接口就是ProxyFactory。 1234567@SPI(\"javassist\")public interface ProxyFactory { @Adaptive({Constants.PROXY_KEY}) &lt;T&gt; T getProxy(Invoker&lt;T&gt; invoker) throws RpcException; @Adaptive({Constants.PROXY_KEY}) &lt;T&gt; Invoker&lt;T&gt; getInvoker(T proxy, Class&lt;T&gt; type, URL url) throws RpcException;} ProxyFactory 有两种实现方式，一种是基于 JDK 的代理实现，一种是基于 javassist 的实现。ProxyFactory 接口上定义了@SPI(“javassist”)，默认为 javassist 的实现。 3.5. Dubbo 支持哪些序列化协议？Hessian？Hessian 的数据结构？ dubbo 序列化，阿里尚不成熟的 java 序列化实现。 hessian2 序列化：hessian 是一种跨语言的高效二进制的序列化方式，但这里实际不是原生的 hessian2 序列化，而是阿里修改过的 hessian lite，它是 dubbo RPC 默认启用的序列化方式。 json 序列化：目前有两种实现，一种是采用的阿里的 fastjson 库，另一种是采用 dubbo 中自已实现的简单 json 库，一般情况下，json 这种文本序列化性能不如二进制序列化。 java 序列化：主要是采用 JDK 自带的 java 序列化实现，性能很不理想。 Kryo 和 FST：Kryo 和 FST 的性能依然普遍优于 hessian 和 dubbo 序列化。 Hessian 序列化与 Java 默认的序列化区别？Hessian 是一个轻量级的 remoting on http 工具，采用的是 Binary RPC 协议，所以它很适合于发送二进制数据，同时又具有防火墙穿透能力。 Hessian 支持跨语言串行 比 java 序列化具有更好的性能和易用性 支持的语言比较多 3.6. Protoco Buffer 是什么？ Protocol Buffer 是 Google 出品的一种轻量 &amp; 高效的结构化数据存储格式，性能比 Json、XML 真的强！太！多！Protocol Buffer 的序列化 &amp; 反序列化简单 &amp; 速度快的原因是： 编码 / 解码 方式简单（只需要简单的数学运算 = 位移等等） 采用 Protocol Buffer 自身的框架代码 和 编译器 共同完成 Protocol Buffer 的数据压缩效果好（即序列化后的数据量体积小）的原因是： 采用了独特的编码方式，如 Varint、Zigzag 编码方式等等 采用 T - L - V 的数据存储方式：减少了分隔符的使用 &amp; 数据存储得紧凑 3.7. 注册中心挂了可以继续通信吗？ 可以。Dubbo 消费者在应用启动时会从注册中心拉取已注册的生产者的地址接口，并缓存在本地。每次调用时，按照本地存储的地址进行调用。 3.8. ZooKeeper 原理是什么？ZooKeeper 有什么用？ ZooKeeper 是一个分布式应用协调系统，已经用到了许多分布式项目中，用来完成统一命名服务、状态同步服务、集群管理、分布式应用配置项的管理等工作。 每个 Server 在内存中存储了一份数据； Zookeeper 启动时，将从实例中选举一个 leader（Paxos 协议）； Leader 负责处理数据更新等操作（Zab 协议）； 一个更新操作成功，当且仅当大多数 Server 在内存中成功修改数据。 3.9. Netty 有什么用？NIO/BIO/AIO 有什么用？有什么区别？ Netty 是一个“网络通讯框架”。Netty 进行事件处理的流程。Channel是连接的通道，是 ChannelEvent 的产生者，而ChannelPipeline可以理解为 ChannelHandler 的集合。 IO 的方式通常分为几种： 同步阻塞的 BIO 同步非阻塞的 NIO 异步非阻塞的 AIO 在使用同步 I/O 的网络应用中，如果要同时处理多个客户端请求，或是在客户端要同时和多个服务器进行通讯，就必须使用多线程来处理。NIO 基于 Reactor，当 socket 有流可读或可写入 socket时，操作系统会相应的通知引用程序进行处理，应用再将流读取到缓冲区或写入操作系统。也就是说，这个时候，已经不是一个连接就要对应一个处理线程了，而是有效的请求，对应一个线程，当连接没有数据时，是没有工作线程来处理的。与 NIO 不同，当进行读写操作时，只须直接调用 API 的 read 或 write方法即可。这两种方法均为异步的，对于读操作而言，当有流可读取时，操作系统会将可读的流传入 read方法的缓冲区，并通知应用程序；对于写操作而言，当操作系统将 write 方法传递的流写入完毕时，操作系统主动通知应用程序。即可以理解为，read/write 方法都是异步的，完成后会主动调用回调函数。 3.10. 为什么要进行系统拆分？拆分不用 Dubbo 可以吗？ 系统拆分从资源角度分为：应用拆分和数据库拆分。从采用的先后顺序可分为：水平扩展、垂直拆分、业务拆分、水平拆分。 是否使用服务依据实际业务场景来决定。当垂直应用越来越多，应用之间交互不可避免，将核心业务抽取出来，作为独立的服务，逐渐形成稳定的服务中心，使前端应用能更快速的响应多变的市场需求。此时，用于提高业务复用及整合的分布式服务框架(RPC)是关键。当服务越来越多，容量的评估，小服务资源的浪费等问题逐渐显现，此时需增加一个调度中心基于访问压力实时管理集群容量，提高集群利用率。此时，用于提高机器利用率的资源调度和治理中心(SOA)是关键。 3.11. Dubbo 和 Thrift 有什么区别？ Thrift 是跨语言的 RPC 框架。 Dubbo 支持服务治理，而 Thrift 不支持。 转载面试","link":"/2020/04/21/idl9gm/"}],"tags":[{"name":"测试","slug":"测试","link":"/tags/%E6%B5%8B%E8%AF%95/"},{"name":"hexo","slug":"hexo","link":"/tags/hexo/"},{"name":"Java","slug":"Java","link":"/tags/Java/"},{"name":"设计模式","slug":"设计模式","link":"/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"linux","slug":"linux","link":"/tags/linux/"},{"name":"实用","slug":"实用","link":"/tags/%E5%AE%9E%E7%94%A8/"},{"name":"面试","slug":"面试","link":"/tags/%E9%9D%A2%E8%AF%95/"},{"name":"Java基础","slug":"Java基础","link":"/tags/Java%E5%9F%BA%E7%A1%80/"},{"name":"分布式","slug":"分布式","link":"/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"}],"categories":[{"name":"测试","slug":"测试","link":"/categories/%E6%B5%8B%E8%AF%95/"},{"name":"hexo","slug":"hexo","link":"/categories/hexo/"},{"name":"设计模式","slug":"设计模式","link":"/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"linux","slug":"linux","link":"/categories/linux/"},{"name":"面试","slug":"面试","link":"/categories/%E9%9D%A2%E8%AF%95/"},{"name":"Java基础","slug":"面试/Java基础","link":"/categories/%E9%9D%A2%E8%AF%95/Java%E5%9F%BA%E7%A1%80/"}]}